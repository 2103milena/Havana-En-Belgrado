(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["grid"] = factory();
	else
		root["grid"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 37);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function clamp(num, min, max, returnNaN) {
    if (num > max) {
        return returnNaN ? NaN : max;
    }
    if (num < min) {
        return returnNaN ? NaN : min;
    }
    return num;
}
exports.clamp = clamp;
function isRow(rowCol) {
    return rowCol === 'row';
}
exports.isRow = isRow;
function isCol(rowCol) {
    return rowCol === 'col';
}
exports.isCol = isCol;
function isNumber(num) {
    return typeof num === 'number' && !isNaN(num);
}
exports.isNumber = isNumber;
function isElementWithStyle(node) {
    return !!node.style;
}
exports.isElementWithStyle = isElementWithStyle;
function isElement(node) {
    return !!(node &&
        node.nodeName);
}
exports.isElement = isElement;
function toArray(thing) {
    return thing != undefined && !Array.isArray(thing) ? [thing] : thing || [];
}
exports.toArray = toArray;
function position(elem, t, l, b, r, h, w) {
    if (t != null) {
        elem.style.top = t + 'px';
    }
    if (l != null) {
        elem.style.left = l + 'px';
    }
    if (b != null) {
        elem.style.bottom = b + 'px';
    }
    if (r != null) {
        elem.style.right = r + 'px';
    }
    if (h != null) {
        elem.style.height = h + 'px';
    }
    if (w != null) {
        elem.style.width = w + 'px';
    }
    elem.style.position = 'absolute';
}
exports.position = position;
function position3D(elem, t, l) {
    var x = '0';
    var y = '0';
    if (l != null) {
        x = l + 'px';
    }
    if (t != null) {
        y = t + 'px';
    }
    elem.style.transform = 'translate3d(' + x + ',' + y + ',0)';
}
exports.position3D = position3D;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function create(grid) {
    var dirty = true;
    var unbindDrawHandler = null;
    function listenForDraw() {
        if (!unbindDrawHandler) {
            unbindDrawHandler = grid.eventLoop.bind('grid-draw', function () {
                dirtyCleanInstance.setClean();
            });
        }
    }
    var dirtyCleanInstance = {
        isDirty: function () {
            return dirty;
        },
        isClean: function () {
            return !dirty;
        },
        setDirty: function () {
            dirty = true;
            if (grid.requestDraw) {
                grid.requestDraw();
            }
        },
        setClean: function () {
            dirty = false;
        },
        disable: function () {
            if (unbindDrawHandler) {
                unbindDrawHandler();
                unbindDrawHandler = null;
            }
        },
        enable: function () {
            listenForDraw();
        }
    };
    dirtyCleanInstance.enable();
    return dirtyCleanInstance;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var debounce_1 = __webpack_require__(6);
var listeners_1 = __webpack_require__(40);
var mousewheel_1 = __webpack_require__(41);
var util = __webpack_require__(0);
exports.EVENTS = ['click', 'mousedown', 'mouseup', 'mousemove', 'dblclick', 'keydown', 'keypress', 'keyup', 'copy', 'paste'];
exports.GRID_EVENTS = ['grid-drag-start', 'grid-drag', 'grid-cell-drag', 'grid-drag-end', 'grid-cell-mouse-move'];
var GridCustomMouseEvents = {
    'grid-drag': true,
    'grid-cell-drag': true,
    'grid-drag-start': true,
    'grid-drag-end': true,
    'grid-cell-mouse-move': true,
};
exports.isAnnotatedGridCustomMouseEvent = function (e) { return !!GridCustomMouseEvents[e.type]; };
exports.ANNOTATED_MOUSE_EVENTS = {
    click: true,
    dblclick: true,
    mousedown: true,
    mousemove: true,
    mouseup: true,
};
exports.ANNOTATED_MOUSE_EVENTS_MAP = exports.ANNOTATED_MOUSE_EVENTS;
exports.isAnnotatedMouseEvent = function (e) { return !!exports.ANNOTATED_MOUSE_EVENTS_MAP[e.type]; };
exports.isAnnotatedMouseEventOfType = function (e, type) {
    return type === e.type;
};
exports.ANNOTATED_KEY_EVENTS = {
    keydown: true,
    keypress: true,
    keyup: true,
};
exports.ANNOTATED_KEY_EVENTS_MAP = exports.ANNOTATED_KEY_EVENTS;
exports.isAnnotatedKeyEvent = function (e) { return !!exports.ANNOTATED_KEY_EVENTS_MAP[e.type]; };
exports.isAnnotatedMouseOrKeyEvent = function (e) {
    return exports.isAnnotatedKeyEvent(e) ||
        exports.isAnnotatedMouseEvent(e);
};
exports.isAnnotatedEvent = function (e) {
    return exports.isAnnotatedMouseOrKeyEvent(e) ||
        exports.isAnnotatedGridCustomMouseEvent(e);
};
function create() {
    var handlersByName = {};
    var domUnbindFns = [];
    var interceptors = listeners_1.default();
    var exitListeners = listeners_1.default();
    var unbindAll;
    var eloop = {
        isRunning: false,
        destroyed: false,
        setContainer: function (container) {
            var unbindMouseWheelFn = mousewheel_1.default.bind(container, mainLoop);
            exports.EVENTS.forEach(function (name) {
                bindToDomElement(container, name, mainLoop);
            });
            exports.GRID_EVENTS.forEach(function (name) {
                bindToDomElement(window, name, mainLoop);
            });
            unbindAll = function () {
                unbindMouseWheelFn();
                domUnbindFns.slice(0).forEach(function (unbind) {
                    unbind();
                });
                Object.keys(handlersByName).forEach(function (key) {
                    handlersByName[key] = [];
                });
            };
        },
        bind: function () {
            var args = Array.prototype.slice.call(arguments, 0);
            var name = args.filter(function (arg) {
                return typeof arg === 'string';
            })[0];
            var handler = getHandlerFromArgs(args);
            if (!handler || !name) {
                throw new Error('cannot bind without at least name and function');
            }
            var elem = args.filter(function (arg) {
                return util.isElement(arg) || arg === window || arg === document;
            })[0];
            if (!elem) {
                handler._eventLoopIdx = getHandlers(name).push(handler) - 1;
                handler._eventLoopUnbound = false;
                return function () {
                    if (handler._eventLoopUnbound) {
                        return;
                    }
                    handler._eventLoopUnbound = true;
                    var handlers = getHandlers(name);
                    if (handler._eventLoopIdx != undefined) {
                        handlers[handler._eventLoopIdx] = null;
                    }
                    scheduleHandlerCleanUp();
                };
            }
            else {
                var listener = loopWith(handler);
                if (util.isElementWithStyle(elem)) {
                    elem.style.pointerEvents = 'auto';
                }
                return bindToDomElement(elem, name, listener);
            }
        },
        bindOnce: function () {
            var args = Array.prototype.slice.call(arguments, 0);
            var handler = getHandlerFromArgs(args);
            args.splice(args.indexOf(handler), 1, function bindOnceHandler(e) {
                unbind();
                handler(e);
            });
            var unbind = eloop.bind.apply(this, args);
            return unbind;
        },
        fire: function (event) {
            event = typeof event === 'string' ? {
                type: event
            } : event;
            mainLoop(event);
        },
        addInterceptor: interceptors.addListener,
        addExitListener: exitListeners.addListener,
        stopBubbling: function (e) {
            e.gridStopBubbling = true;
            return e;
        }
    };
    function getHandlers(name) {
        var handlers = handlersByName[name];
        if (!handlers) {
            handlers = handlersByName[name] = [];
        }
        return handlers;
    }
    function bindToDomElement(elem, name, listener) {
        elem.addEventListener(name, listener);
        var unbindFn = function () {
            elem.removeEventListener(name, listener);
            domUnbindFns.splice(domUnbindFns.indexOf(unbindFn), 1);
        };
        domUnbindFns.push(unbindFn);
        return unbindFn;
    }
    function getHandlerFromArgs(args) {
        var handler = args.filter(function (arg) {
            return typeof arg === 'function';
        })[0];
        return handler;
    }
    function loopWith(fn) {
        return function (e) {
            loop(e, fn);
        };
    }
    var scheduleHandlerCleanUp = debounce_1.default(function () {
        Object.keys(handlersByName).forEach(function (type) {
            var i = 0;
            var handlers = handlersByName[type];
            if (!handlers) {
                return;
            }
            handlersByName[type] = handlers.filter(function (handler) {
                if (!!handler) {
                    handler._eventLoopIdx = i;
                    i++;
                }
                return !!handler;
            });
        });
    }, 1);
    var mainLoop = loopWith(function (e) {
        getHandlers(e.type).slice(0).some(function (handler) {
            if (!handler) {
                return false;
            }
            handler(e);
            if (e.gridStopBubbling) {
                return true;
            }
            return false;
        });
    });
    function loop(e, bodyFn) {
        if (eloop.logTargets) {
            console.log('target', e.target, 'currentTarget', e.currentTarget);
        }
        var isOuterLoopRunning = eloop.isRunning;
        eloop.isRunning = true;
        interceptors.notify(e);
        if (!e.gridStopBubbling) {
            bodyFn(e);
        }
        if (!isOuterLoopRunning) {
            eloop.isRunning = false;
            exitListeners.notify(e);
        }
    }
    eloop.bind('grid-destroy', function () {
        unbindAll();
        eloop.destroyed = true;
    });
    return eloop;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var Reference, assertRef, isRef, ref;

  Reference = (function() {

    function Reference(name, code) {
      this.name = name;
      this.code = code;
    }

    return Reference;

  })();

  ref = function(name, code) {
    return new Reference(name, code);
  };

  isRef = function(ref) {
    return ref instanceof Reference;
  };

  assertRef = function(ref) {
    if (!isRef(ref)) {
      throw new Error('Invalid reference');
    }
    return ref;
  };

  module.exports = {
    ref: ref,
    isRef: isRef,
    assertRef: assertRef
  };

}).call(this);


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isDirtyPropWithPre = function (dirtyProp) {
    return !!dirtyProp.preDirty;
};
var isDirtyPropWithOn = function (dirtyProp) {
    return !!dirtyProp.onDirty;
};
function add(obj, props, dirtyCleans) {
    props.forEach(function (prop) {
        var val;
        var name = prop.name || prop;
        var initialVal = obj[name];
        Object.defineProperty(obj, name, {
            enumerable: true,
            get: function () {
                return val;
            },
            set: function (newVal) {
                var oldVal = val;
                var isChanged = newVal !== oldVal;
                if (isChanged && isDirtyPropWithPre(prop)) {
                    prop.preDirty();
                }
                val = newVal;
                if (isChanged) {
                    dirtyCleans.forEach(function (dirtyClean) {
                        dirtyClean.setDirty();
                    });
                    if (isDirtyPropWithOn(prop)) {
                        prop.onDirty(newVal, oldVal);
                    }
                }
            }
        });
        obj[name] = initialVal;
    });
    return obj;
}
exports.add = add;
exports.default = add;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var dirty_props_1 = __webpack_require__(4);
var WATCHED_PROP_NAMES = ['top', 'left', 'height', 'width', 'units', 'space'];
exports.toStandardSpace = function (space) {
    if (space === 'real') {
        return 'view';
    }
    return space;
};
var getTop = function (range) {
    return range.top;
};
var setTop = function (range, p) {
    range.top = p;
    return range;
};
var getHeight = function (range) {
    return range.height;
};
var setHeight = function (range, s) {
    range.height = s;
    return range;
};
var getLeft = function (range) {
    return range.left;
};
var setLeft = function (range, p) {
    range.left = p;
    return range;
};
var getWidth = function (range) {
    return range.width;
};
var setWidth = function (range, s) {
    range.width = s;
    return range;
};
exports.rowPositionRangeDimension = {
    getPosition: getTop,
    getSize: getHeight,
    setPosition: setTop,
    setSize: setHeight,
};
exports.colPositionRangeDimension = {
    getPosition: getLeft,
    getSize: getWidth,
    setPosition: setLeft,
    setSize: setWidth,
};
function mixin(range, dirtyClean, parentDirtyClean, propOpts) {
    range = range || {};
    var rangeResult = Object.assign(range, {
        isDirty: dirtyClean.isDirty,
        units: 'cell',
        space: 'data',
    });
    rangeResult._positionRangeDirtyClean = dirtyClean;
    var watchedProperties = WATCHED_PROP_NAMES;
    if (propOpts) {
        watchedProperties = WATCHED_PROP_NAMES.map(function (propName) {
            return {
                name: propName,
                onDirty: propOpts.onDirty,
                preDirty: propOpts.preDirty
            };
        });
    }
    var dirtyCleans = [dirtyClean];
    if (parentDirtyClean) {
        dirtyCleans.push(parentDirtyClean);
    }
    dirty_props_1.default(rangeResult, watchedProperties, dirtyCleans);
    return rangeResult;
}
exports.mixin = mixin;
exports.default = mixin;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var debouncedFnProps = { cancel: function () { } };
function debounce(fn, delay) {
    var f = Object.assign(function debounced() {
        if (f.timeout) {
            clearTimeout(f.timeout);
            f.timeout = undefined;
        }
        if (!f.canceled) {
            f.timeout = window.setTimeout(fn, delay);
        }
        f.cancel = function () {
            if (f.timeout != undefined) {
                clearTimeout(f.timeout);
            }
            f.timeout = undefined;
            f.canceled = true;
        };
    }, debouncedFnProps);
    return f;
}
exports.debounce = debounce;
exports.default = debounce;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var range_util_1 = __webpack_require__(11);
var AbstractSpaceConverter = (function () {
    function AbstractSpaceConverter(grid) {
        var _this = this;
        this.grid = grid;
        this.up = function (i) { return _this.row.prev(i); };
        this.down = function (i) { return _this.row.next(i); };
        this.left = function (i) { return _this.col.prev(i); };
        this.right = function (i) { return _this.col.next(i); };
    }
    AbstractSpaceConverter.prototype.iterate = function () {
        var args = range_util_1.getArgs(arguments);
        var range = args.range;
        var rowFn = args.rowFn;
        var cellFn = args.cellFn;
        rowloop: for (var r = range.top; r !== undefined && r < range.top + range.height; r = this.row.next(r)) {
            var rowResult = void 0;
            if (rowFn) {
                rowResult = rowFn(r);
            }
            colloop: for (var c = range.left; c !== undefined && c < range.left + range.width; c = this.col.next(c)) {
                if (cellFn) {
                    var result = cellFn(r, c, rowResult);
                    if (result === false) {
                        break rowloop;
                    }
                    else if (result === true) {
                        break colloop;
                    }
                }
            }
        }
    };
    return AbstractSpaceConverter;
}());
exports.AbstractSpaceConverter = AbstractSpaceConverter;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(0);
var AbstractDimensionalSpaceConverter = (function () {
    function AbstractDimensionalSpaceConverter(gridDimension) {
        this.gridDimension = gridDimension;
    }
    AbstractDimensionalSpaceConverter.prototype.clamp = function (idx) {
        return util.clamp(idx, 0, this.count() - 1);
    };
    AbstractDimensionalSpaceConverter.prototype.prev = function (coord) {
        return this.iterateWhileHidden(-1, coord);
    };
    AbstractDimensionalSpaceConverter.prototype.next = function (coord) {
        return this.iterateWhileHidden(1, coord);
    };
    AbstractDimensionalSpaceConverter.prototype.get = function (coord) {
        return this.gridDimension.rowColModel.get(this.toVirtual(coord));
    };
    AbstractDimensionalSpaceConverter.prototype.indexes = function (opts) {
        if (opts === void 0) { opts = {}; }
        opts.from = opts.from || 0;
        var count = this.count();
        opts.to = (opts.to && opts.to + 1) ||
            (opts.length && opts.length + opts.from) ||
            count;
        var indexes = [];
        for (var idx = Math.max(opts.from, 0); idx != undefined && idx < Math.min(opts.to, count); idx = opts.reverse ? this.prev(idx) : this.next(idx)) {
            indexes.push(idx);
        }
        return indexes;
    };
    AbstractDimensionalSpaceConverter.prototype.iterate = function () {
        var opts;
        var fn;
        if (arguments.length === 2) {
            opts = arguments[0];
            fn = arguments[1];
        }
        else {
            fn = arguments[0];
        }
        this.indexes(opts).some(function (idx) {
            return !!fn(idx);
        });
    };
    AbstractDimensionalSpaceConverter.prototype.iterateWhileHidden = function (step, start) {
        if (step === void 0) { step = 1; }
        for (var i = start + step; i < this.count() && i >= 0; i += step) {
            if (!this.get(i).hidden) {
                return i;
            }
        }
        return undefined;
    };
    return AbstractDimensionalSpaceConverter;
}());
exports.AbstractDimensionalSpaceConverter = AbstractDimensionalSpaceConverter;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var debounce_1 = __webpack_require__(6);
var dirty_clean_1 = __webpack_require__(1);
var dirty_props_1 = __webpack_require__(4);
var pass_through_1 = __webpack_require__(42);
var util = __webpack_require__(0);
var AbstractRowColModel = (function () {
    function AbstractRowColModel(grid, name, lengthName, defaultSize) {
        this.descriptors = [];
        this._numFixed = 0;
        this._numHeaders = 0;
        this._selected = [];
        this.grid = grid;
        this.name = name;
        this.dirtyClean = dirty_clean_1.default(grid);
        this.builderDirtyClean = dirty_clean_1.default(grid);
        this.areBuildersDirty = this.builderDirtyClean.isDirty;
        this.isDirty = this.dirtyClean.isDirty;
        this.ROW_COL_EVENT_TYPE = 'grid-' + name + '-change';
        this.defaultSize = defaultSize;
        this.lengthName = lengthName;
        this.fireSelectionChange = debounce_1.default(function () {
            grid.eventLoop.fire('grid-' + name + '-selection-change');
        }, 1);
    }
    AbstractRowColModel.prototype.add = function (_toAdd) {
        var _this = this;
        if (!_toAdd) {
            return;
        }
        var toAdd = util.toArray(_toAdd);
        toAdd.forEach(function (descriptor) {
            if (descriptor.header) {
                _this.descriptors.splice(_this._numHeaders, 0, descriptor);
                _this._numFixed++;
                _this._numHeaders++;
            }
            else {
                if (descriptor.fixed) {
                    if (!_this.descriptors.length || _this.descriptors[_this.descriptors.length - 1].fixed) {
                        _this._numFixed++;
                    }
                    else {
                        throw new Error('Cannot add a fixed column after an unfixed one');
                    }
                }
                _this.descriptors.push(descriptor);
            }
        });
        this.updateDescriptorIndices();
        this.setDescriptorsDirty({
            action: 'add',
            descriptors: toAdd
        });
    };
    AbstractRowColModel.prototype.addHeaders = function (_toAdd) {
        if (!_toAdd) {
            return;
        }
        var toAdd = util.toArray(_toAdd);
        toAdd.forEach(function (headerDescriptor) {
            headerDescriptor.header = true;
        });
        this.add(toAdd);
    };
    AbstractRowColModel.prototype.header = function (index) {
        return this.descriptors[index];
    };
    AbstractRowColModel.prototype.get = function (index, dataSpace) {
        if (dataSpace) {
            index += this._numHeaders;
        }
        return this.descriptors[index];
    };
    AbstractRowColModel.prototype.length = function (includeHeaders) {
        var subtract = includeHeaders ? 0 : this._numHeaders;
        return this.descriptors.length - subtract;
    };
    AbstractRowColModel.prototype.remove = function (descriptor, dontUpdateIndex) {
        var index = this.descriptors.indexOf(descriptor);
        if (index !== -1) {
            this.descriptors.splice(index, 1);
            if (descriptor.header) {
                this._numFixed--;
                this._numHeaders--;
            }
            else if (descriptor.fixed) {
                this._numFixed--;
            }
        }
        if (!dontUpdateIndex) {
            this.updateDescriptorIndices();
            this.setDescriptorsDirty({
                action: 'remove',
                descriptors: [descriptor]
            });
        }
    };
    AbstractRowColModel.prototype.clear = function (includeHeaders) {
        var removed;
        if (includeHeaders) {
            removed = this.descriptors;
            this.descriptors = [];
            this._numFixed = 0;
            this._numHeaders = 0;
        }
        else {
            removed = this.descriptors.slice(this._numHeaders);
            this.descriptors = this.descriptors.slice(0, this._numHeaders);
            this._numFixed = this._numHeaders;
        }
        this.updateDescriptorIndices();
        if (removed && removed.length) {
            this.setDescriptorsDirty({
                action: 'remove',
                descriptors: removed
            });
        }
    };
    AbstractRowColModel.prototype.move = function (_fromIndexes, target, after) {
        var _this = this;
        var _a;
        var fromIndexes = util.toArray(_fromIndexes);
        if (fromIndexes.length === 1) {
            var from = fromIndexes[0];
            this.descriptors.splice(target, 0, this.descriptors.splice(from, 1)[0]);
            this.setDescriptorsDirty({
                action: 'move',
                descriptors: [this.get(from), this.get(target)]
            });
        }
        else {
            while (fromIndexes.indexOf(target) !== -1 && target !== -1) {
                target--;
                after = true;
            }
            var toValue = this.descriptors[target];
            var removed = fromIndexes
                .sort(function (a, b) { return b - a; })
                .map(function (fromIndex) {
                var removedDescriptors = _this.descriptors.splice(fromIndex, 1);
                return removedDescriptors[0];
            });
            removed.reverse();
            (_a = this.descriptors).splice.apply(_a, [this.descriptors.indexOf(toValue) + (after ? 1 : 0), 0].concat(removed));
            this.updateDescriptorIndices();
            this.setDescriptorsDirty({
                action: 'move',
                descriptors: removed.concat(toValue)
            });
        }
    };
    AbstractRowColModel.prototype.numHeaders = function () {
        return this._numHeaders;
    };
    AbstractRowColModel.prototype.numFixed = function (excludeHeaders) {
        return this._numFixed - (excludeHeaders ? this._numHeaders : 0);
    };
    AbstractRowColModel.prototype.toVirtual = function (dataIndex) {
        return dataIndex + this.numHeaders();
    };
    AbstractRowColModel.prototype.toData = function (virtualIndex) {
        return virtualIndex - this.numHeaders();
    };
    AbstractRowColModel.prototype.select = function (_indexes, dontFire) {
        var _this = this;
        var indexes = util.toArray(_indexes);
        var changes = indexes
            .filter(function (idx) {
            var hasDescriptor = !!_this.get(idx, true);
            if (!hasDescriptor) {
                console.warn('Tried to select index that had no descriptor', idx);
            }
            return hasDescriptor;
        })
            .map(function (idx) {
            var descriptor = _this.get(idx, true);
            if (!descriptor.selected && descriptor.selectable !== false) {
                _this.addDragReadyClass(descriptor, idx);
                descriptor.selected = true;
                _this._selected.push(idx);
                return idx;
            }
            return undefined;
        })
            .filter(function (c) { return c != undefined; });
        if (changes.length && !dontFire) {
            this.fireSelectionChange();
        }
    };
    AbstractRowColModel.prototype.deselect = function (_indexes, dontFire) {
        var _this = this;
        var indexes = util.toArray(_indexes);
        var selectedMap = this._selected.reduce(function (map, selectedIndex) {
            map[selectedIndex] = selectedIndex;
            return map;
        }, {});
        var changes = indexes
            .filter(function (idx) {
            var hasDescriptor = !!_this.get(idx, true);
            if (!hasDescriptor) {
                console.warn('Tried to deselect index that had no descriptor', idx);
            }
            return hasDescriptor;
        })
            .map(function (idx) {
            var descriptor = _this.get(idx, true);
            _this.removeDragReadyClass(descriptor);
            if (descriptor.selected) {
                descriptor.selected = false;
                selectedMap[idx] = false;
                return idx;
            }
            return undefined;
        })
            .filter(function (c) { return c != undefined; });
        this._selected =
            Object.keys(selectedMap)
                .reduce(function (array, selectedKey) {
                var idx = selectedMap[selectedKey];
                if (idx !== false) {
                    array.push(idx);
                }
                return array;
            }, []);
        if (changes.length && !dontFire) {
            this.fireSelectionChange();
        }
    };
    AbstractRowColModel.prototype.toggleSelect = function (index) {
        var descriptor = this.get(index, true);
        if (descriptor.selected) {
            this.deselect(index);
        }
        else {
            this.select(index);
        }
    };
    AbstractRowColModel.prototype.clearSelected = function () {
        return this.deselect(this.getSelected().slice(0));
    };
    AbstractRowColModel.prototype.getSelected = function () {
        return this._selected;
    };
    AbstractRowColModel.prototype.allSelected = function () {
        return this.getSelected().length === this.length();
    };
    AbstractRowColModel.prototype.create = function (builder) {
        var _this = this;
        var fixed = false;
        var expanded = false;
        var expandedClass;
        var setExpanded = function (exp) {
            var _a;
            if (!descriptor.children || descriptor.index == undefined) {
                return;
            }
            expanded = exp;
            if (expanded) {
                (_a = _this.descriptors).splice.apply(_a, [descriptor.index + 1, 0].concat(descriptor.children));
                _this.updateDescriptorIndices();
                _this.setDescriptorsDirty({
                    action: 'add',
                    descriptors: descriptor.children
                });
                var top_1 = _this.name === 'row' ? descriptor.index : 0;
                var left = _this.name === 'col' ? descriptor.index : 0;
                var height = _this.name === 'row' ? 1 : Infinity;
                var width = _this.name === 'col' ? 1 : Infinity;
                expandedClass = _this.grid.cellClasses.create(top_1, left, 'grid-expanded', height, width, 'virtual');
                _this.grid.cellClasses.add(expandedClass);
            }
            else {
                _this.descriptors.splice(descriptor.index + 1, descriptor.children.length);
                _this.updateDescriptorIndices();
                _this.setDescriptorsDirty({
                    action: 'remove',
                    descriptors: descriptor.children.slice()
                });
                if (expandedClass) {
                    _this.grid.cellClasses.remove(expandedClass);
                }
            }
        };
        var descriptor = {
            isBuiltActionable: true,
            get fixed() {
                return descriptor.header || !!fixed;
            },
            set fixed(_fixed) {
                fixed = _fixed;
            },
            get expanded() {
                return expanded;
            },
            set expanded(exp) {
                setExpanded(exp);
            }
        };
        dirty_props_1.default(descriptor, ['builder'], [this.builderDirtyClean]);
        dirty_props_1.default(descriptor, [{
                name: 'data', onDirty: function () {
                    _this.grid.dataModel.setDirty();
                }
            }], []);
        descriptor.builder = builder;
        return dirty_props_1.default(descriptor, [{
                name: this.lengthName,
                onDirty: function () {
                    _this.setDescriptorsDirty({
                        action: 'size',
                        descriptors: [descriptor]
                    });
                }
            }, {
                name: 'hidden',
                onDirty: function () {
                    _this.setDescriptorsDirty({
                        action: 'hide',
                        descriptors: [descriptor]
                    });
                }
            }], [this.dirtyClean]);
    };
    AbstractRowColModel.prototype.createBuilder = function (render, update, includeHeaders) {
        if (update === void 0) { update = pass_through_1.default; }
        if (includeHeaders === void 0) { includeHeaders = false; }
        return {
            render: render,
            update: update,
            includeHeaders: includeHeaders
        };
    };
    AbstractRowColModel.prototype.sizeOf = function (index) {
        var descriptor = this.get(index);
        if (!descriptor) {
            return NaN;
        }
        if (descriptor.hidden) {
            return 0;
        }
        var size = descriptor[this.lengthName];
        return size || this.defaultSize;
    };
    AbstractRowColModel.prototype.setDescriptorsDirty = function (eventBody) {
        var event = Object.assign(eventBody, {
            type: this.ROW_COL_EVENT_TYPE
        });
        this.grid.eventLoop.fire(event);
        this.dirtyClean.setDirty();
        this.builderDirtyClean.setDirty();
    };
    AbstractRowColModel.prototype.updateDescriptorIndices = function () {
        var _this = this;
        var oldSelected = this._selected;
        this._selected = [];
        this.descriptors.forEach(function (descriptor, i) {
            descriptor.index = i;
            if (descriptor.selected) {
                _this._selected.push(i);
            }
        });
        if (this._selected.length !== oldSelected.length) {
            this.fireSelectionChange();
            return;
        }
        this._selected.sort();
        oldSelected.sort();
        var change = oldSelected.some(function (idx, i) {
            return idx !== _this._selected[i];
        });
        if (change) {
            this.fireSelectionChange();
        }
    };
    AbstractRowColModel.prototype.addDragReadyClass = function (descriptor, index) {
        if (!descriptor || !(index >= 0)) {
            return;
        }
        var top = this.name === 'row' ? index : -1;
        var left = this.name === 'row' ? -1 : index;
        var dragReadyClass = this.grid.cellClasses.create(top, left, 'grid-col-drag-ready');
        this.grid.cellClasses.add(dragReadyClass);
        descriptor.dragReadyClass = dragReadyClass;
    };
    AbstractRowColModel.prototype.removeDragReadyClass = function (descriptor) {
        if (!descriptor || !descriptor.dragReadyClass) {
            return;
        }
        this.grid.cellClasses.remove(descriptor.dragReadyClass);
        descriptor.dragReadyClass = undefined;
    };
    AbstractRowColModel.prototype.compactAndSort = function () {
        this.rangeStates = this.rangeStates
            .slice()
            .sort(function (a, b) { return a.start - b.start; })
            .reduce(function (newRangeStates, rs) {
            var last = newRangeStates.pop();
            if (!last) {
                return newRangeStates.concat([rs]);
            }
            if (last.end < rs.start) {
                return newRangeStates.concat([last, rs]);
            }
            if (last.end > rs.end) {
                return newRangeStates.concat([last]);
            }
            return newRangeStates.concat([
                {
                    start: last.start,
                    end: rs.end,
                }
            ]);
        }, []);
    };
    return AbstractRowColModel;
}());
exports.AbstractRowColModel = AbstractRowColModel;
function create(grid, name, lengthName, defaultSize) {
    return new AbstractRowColModel(grid, name, lengthName, defaultSize);
}
exports.create = create;
exports.default = create;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var dirty_clean_1 = __webpack_require__(1);
var nullResult = { value: null, formatted: '' };
var loadingResult = { value: null, formatted: 'Loading...' };
function create(grid, loadRows) {
    var dirtyClean = dirty_clean_1.default(grid);
    var getData = function (vR, vC) {
        var cachedRow = getCachedRow(vR);
        if (cachedRow) {
            return __assign({ formatted: '' }, cachedRow[vC]);
        }
        if (loadRows) {
            return grid.cols.converters.virtual.toData(vC) === 0 ?
                loadingResult :
                nullResult;
        }
        return nullResult;
    };
    var getCachedRow = function (vR) {
        var rowDescriptor = grid.rowModel.get(vR);
        return rowDescriptor && rowDescriptor.data;
    };
    function maybeLoadRows() {
        return __awaiter(this, void 0, void 0, function () {
            var extras, visibles, numVisibleRows, currentTopRow, currentBottomRow, row, toFetchSet, toFetch;
            return __generator(this, function (_a) {
                if (!loadRows) {
                    return [2];
                }
                extras = [];
                visibles = [];
                numVisibleRows = grid.viewPort.rows;
                currentTopRow = grid.cellScrollModel.row;
                currentBottomRow = currentTopRow + numVisibleRows;
                for (row = Math.max(0, currentTopRow - numVisibleRows); row < Math.min(currentBottomRow + 1 + numVisibleRows, grid.rows.converters.data.count()); row++) {
                    if (getCachedRow(grid.rows.converters.data.toVirtual(row))) {
                        continue;
                    }
                    if (row >= currentBottomRow) {
                        extras.push(row);
                    }
                    else {
                        visibles.push(row);
                    }
                }
                if (!extras.length && !visibles.length) {
                    return [2];
                }
                if (!visibles.length && extras.length < (numVisibleRows / 2)) {
                    return [2];
                }
                toFetchSet = new Set(visibles);
                extras.forEach(function (r) { return toFetchSet.add(r); });
                toFetch = Array.from(toFetchSet);
                if (!toFetch.length) {
                    return [2];
                }
                loadRows(toFetch);
                return [2];
            });
        });
    }
    grid.eventLoop.bind('grid-cell-scroll', function () {
        maybeLoadRows();
    });
    grid.eventLoop.bind('grid-viewport-change', function () {
        maybeLoadRows();
    });
    return {
        isDirty: dirtyClean.isDirty,
        setDirty: dirtyClean.setDirty,
        get: function (dataRow, dataCol) {
            return getData(grid.rows.converters.data.toVirtual(dataRow), grid.cols.converters.data.toVirtual(dataCol));
        },
        getHeader: function (virtualRow, virtualCol) {
            return getData(virtualRow, virtualCol);
        },
        set: function (rowOrData, c, datum) {
            var data;
            if (!Array.isArray(rowOrData)) {
                if (typeof datum === 'string') {
                    datum = datum.replace('[rR]', '').replace('[cC]', '').split(' ');
                }
                data = [{
                        row: rowOrData,
                        col: c,
                        value: datum
                    }];
            }
            else {
                data = rowOrData;
            }
            data.forEach(function (change) {
                var rowDescriptor = grid.rowModel.get(change.row);
                var rowData = rowDescriptor.data;
                if (!rowData) {
                    rowData = rowDescriptor.data = [];
                }
                rowData[grid.cols.converters.data.toVirtual(change.col)] = { value: change.value, formatted: change.formatted || change.value };
            });
        }
    };
}
exports.create = create;
exports.default = create;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function intersect(range1, range2) {
    var range2Start = range2[0];
    var range1Start = range1[0];
    var range1End = range1Start + range1[1] - 1;
    var range2End = range2Start + range2[1] - 1;
    if (range2Start > range1End || range2End < range1Start) {
        return null;
    }
    var resultStart = (range1Start > range2Start ? range1Start : range2Start);
    var resultEnd = (range1End < range2End ? range1End : range2End);
    return [
        resultStart,
        resultEnd - resultStart + 1
    ];
}
exports.intersect = intersect;
function union(range1, range2) {
    if (!range1) {
        return range2;
    }
    if (!range2) {
        return range1;
    }
    var range2Start = range2[0];
    var range2End = range2Start + range2[1] - 1;
    var range1Start = range1[0];
    var range1End = range1Start + range1[1] - 1;
    var resultStart = (range1Start < range2Start ? range1Start : range2Start);
    return [
        resultStart, (range1End > range2End ? range1End : range2End) - resultStart + 1
    ];
}
exports.union = union;
function createFromPoints(r1, c1, r2, c2) {
    var range = {};
    if (r1 < r2) {
        range.top = r1;
        range.height = r2 - r1 + 1;
    }
    else {
        range.top = r2;
        range.height = r1 - r2 + 1;
    }
    if (c1 < c2) {
        range.left = c1;
        range.width = c2 - c1 + 1;
    }
    else {
        range.left = c2;
        range.width = c1 - c2 + 1;
    }
    return range;
}
exports.createFromPoints = createFromPoints;
function iterate() {
    var args = this.getArgs(arguments);
    var range = args.range;
    var cellFn = args.cellFn;
    var rowFn = args.rowFn;
    for (var r = range.top; r < range.top + range.height; r++) {
        var rowResult = void 0;
        if (rowFn) {
            rowResult = rowFn(r);
        }
        for (var c = range.left; c < range.left + range.width; c++) {
            if (cellFn) {
                cellFn(r, c, rowResult);
            }
        }
    }
}
exports.iterate = iterate;
function getArgs(args) {
    var range = args[0];
    var cellFn = args[1];
    var rowFn;
    if (args.length === 3) {
        cellFn = args[2];
        rowFn = args[1];
    }
    return {
        range: range,
        cellFn: cellFn,
        rowFn: rowFn
    };
}
exports.getArgs = getArgs;
function equal(r1, r2) {
    return r1.top === r2.top &&
        r1.left === r2.left &&
        r1.width === r2.width &&
        r1.height === r2.height;
}
exports.equal = equal;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var dirty_clean_1 = __webpack_require__(1);
var dirty_props_1 = __webpack_require__(4);
var position_range_1 = __webpack_require__(5);
function create(grid) {
    var dirtyClean = dirty_clean_1.default(grid);
    var descriptors = [];
    var cachedClassMatrix = [];
    var api = {
        add: function (descriptor) {
            descriptors.push(descriptor);
            addOrRemoveCachedClass(descriptor);
            if (descriptor._cellClassDirtyClean) {
                descriptor._cellClassDirtyClean.enable();
            }
            dirtyClean.setDirty();
        },
        remove: function (descriptor) {
            var index = descriptors.indexOf(descriptor);
            if (index !== -1) {
                descriptors.splice(index, 1);
                addOrRemoveCachedClass(descriptor, true);
                if (descriptor._cellClassDirtyClean) {
                    descriptor._cellClassDirtyClean.disable();
                }
                dirtyClean.setDirty();
            }
        },
        getAll: function () {
            return descriptors.slice(0);
        },
        getCachedClasses: function (vRow, vCol) {
            return cachedClassMatrix[vRow] && cachedClassMatrix[vRow][vCol] || [];
        },
        create: function (top, left, className, height, width, space) {
            var thisDirtyClean = dirty_clean_1.default(grid);
            var descriptor = position_range_1.default({
                _cellClassDirtyClean: thisDirtyClean
            }, thisDirtyClean, dirtyClean, {
                preDirty: classPreDirty,
                onDirty: classOnDirty
            });
            function classPreDirty() {
                if (descriptor) {
                    addOrRemoveCachedClass(descriptor, true);
                }
            }
            function classOnDirty() {
                if (descriptor) {
                    addOrRemoveCachedClass(descriptor);
                }
            }
            dirty_props_1.default(descriptor, [{
                    name: 'class',
                    preDirty: classPreDirty,
                    onDirty: classOnDirty
                }], [thisDirtyClean, dirtyClean]);
            descriptor.space = space || descriptor.space;
            descriptor.top = top;
            descriptor.left = left;
            descriptor.height = height || 1;
            descriptor.width = width || 1;
            descriptor.class = className;
            return descriptor;
        },
        isDirty: dirtyClean.isDirty
    };
    function regnerateCache() {
        cachedClassMatrix = [];
        api.getAll().forEach(function (descriptor) {
            addOrRemoveCachedClass(descriptor);
        });
    }
    grid.eventLoop.bind('grid-row-change', regnerateCache);
    grid.eventLoop.bind('grid-col-change', regnerateCache);
    function addOrRemoveCachedClass(descriptor, isRemove) {
        var top = descriptor.top, left = descriptor.left, height = descriptor.height, width = descriptor.width, space = descriptor.space;
        var className = descriptor.class;
        if (top === undefined || height === undefined || left === undefined || width === undefined || className === undefined) {
            return;
        }
        for (var r = top; r < Math.min(top + height, grid.rowModel.length(true)); r++) {
            for (var c = left; c < Math.min(left + width, grid.colModel.length(true)); c++) {
                var spaceKey = position_range_1.toStandardSpace(space);
                var vRow = grid[spaceKey].row.toVirtual(r);
                var vCol = grid[spaceKey].col.toVirtual(c);
                var cols = cachedClassMatrix[vRow];
                if (!cols) {
                    cols = cachedClassMatrix[vRow] = [];
                }
                var cellClasses = cols[vCol];
                if (!cellClasses) {
                    if (!isRemove) {
                        cols[vCol] = [className];
                    }
                    continue;
                }
                if (!isRemove) {
                    if (cellClasses.indexOf(className) === -1) {
                        cellClasses.push(className);
                    }
                }
                else {
                    var index = cellClasses.indexOf(className);
                    if (index !== -1) {
                        cellClasses.splice(index, 1);
                    }
                }
            }
        }
    }
    return api;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var event_loop_1 = __webpack_require__(2);
function create(grid) {
    var _annotateEventFromDataCoords = function (e, dataRow, dataCol) {
        e.realRow = grid.data.row.toView(dataRow);
        e.realCol = grid.data.col.toView(dataCol);
        e.virtualRow = grid.data.row.toVirtual(dataRow);
        e.virtualCol = grid.data.col.toVirtual(dataCol);
        e.row = dataRow;
        e.col = dataCol;
        return e;
    };
    var _annotateEventInternal = function (e) {
        var dataRow = grid.navigationModel.focus.row;
        var dataCol = grid.navigationModel.focus.col;
        _annotateEventFromDataCoords(e, dataRow, dataCol);
    };
    var annotateEvent = function (e) {
        if (event_loop_1.isAnnotatedKeyEvent(e)) {
            _annotateEventInternal(e);
        }
    };
    grid.eventLoop.addInterceptor(annotateEvent);
    var model = {
        _annotateEvent: annotateEvent
    };
    return model;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var custom_event_1 = __webpack_require__(15);
var event_loop_1 = __webpack_require__(2);
var PROPS_TO_COPY_FROM_MOUSE_EVENTS = ['clientX', 'clientY', 'gridX', 'gridY', 'layerX', 'layerY', 'row', 'col', 'realRow', 'realCol', 'virtualRow', 'virtualCol'];
function create(grid) {
    var scrollInterval;
    var lastMoveRow;
    var lastMoveCol;
    var model = {
        rowInfo: {
            view: function (e) {
                return e.realRow;
            },
            virtual: function (e) {
                return e.virtualRow;
            },
            data: function (e) {
                return e.row;
            },
            gridPx: function (e) {
                return e.gridY;
            },
            layerPx: function (e) {
                return e.layerY;
            }
        },
        colInfo: {
            view: function (e) {
                return e.realCol;
            },
            virtual: function (e) {
                return e.virtualCol;
            },
            data: function (e) {
                return e.col;
            },
            gridPx: function (e) {
                return e.gridX;
            },
            layerPx: function (e) {
                return e.layerX;
            }
        },
        _annotateEvent: function (e) {
            if (event_loop_1.isAnnotatedMouseEvent(e)) {
                model._annotateEventInternal(e);
            }
        },
        _annotateEventFromViewCoords: function (e, viewRow, viewCol) {
            e.realRow = viewRow;
            e.realCol = viewCol;
            e.virtualRow = grid.view.row.toVirtual(e.realRow);
            e.virtualCol = grid.view.col.toVirtual(e.realCol);
            e.row = grid.virtual.row.toData(e.virtualRow);
            e.col = grid.virtual.col.toData(e.virtualCol);
            return e;
        },
        _annotateEventInternal: function (e) {
            var y = grid.viewPort.toGridY(e.clientY);
            var x = grid.viewPort.toGridX(e.clientX);
            var viewRow = grid.rows.viewPort.toViewFromPx(y);
            var viewCol = grid.cols.viewPort.toViewFromPx(x);
            model._annotateEventFromViewCoords(e, viewRow, viewCol);
            e.gridX = x;
            e.gridY = y;
        },
    };
    grid.eventLoop.addInterceptor(function (e) {
        model._annotateEvent(e);
        if (event_loop_1.isAnnotatedMouseEventOfType(e, 'mousedown')) {
            if (e.currentTarget === grid.container) {
                setupDragEventForMouseDown(e);
            }
        }
        else if (event_loop_1.isAnnotatedMouseEventOfType(e, 'mousemove')) {
            if (e.row !== lastMoveRow || e.col !== lastMoveCol) {
                createAndFireCustomMouseEvent('grid-cell-mouse-move', e);
                lastMoveRow = e.row;
                lastMoveCol = e.col;
            }
        }
    });
    function calculateColScrollDiff(e) {
        var colDiff = 0;
        if (e.clientX > (grid.container && grid.container.getBoundingClientRect().right || window.innerWidth)) {
            colDiff = 1;
        }
        else if (grid.viewPort.toGridX(e.clientX) < grid.virtualPixelCellModel.fixedWidth()) {
            colDiff = -1;
        }
        return colDiff;
    }
    function calculateRowScrollDiff(e) {
        var rowDiff = 0;
        if (e.clientY > (grid.container && grid.container.getBoundingClientRect().bottom || window.innerHeight)) {
            rowDiff = 1;
        }
        else if (grid.viewPort.toGridY(e.clientY) < grid.virtualPixelCellModel.fixedHeight()) {
            rowDiff = -1;
        }
        return rowDiff;
    }
    function setupDragEventForMouseDown(downEvent) {
        var lastDragRow = downEvent.row;
        var lastDragCol = downEvent.col;
        var dragStarted = false;
        var unbindAutoScrollDrag;
        var lastX = downEvent.clientX;
        var lastY = downEvent.clientY;
        var unbindMove = grid.eventLoop.bind(window, 'mousemove', function (mousemoveEvent) {
            if (dragStarted && !mousemoveEvent.which) {
                console.log('mousemove unbind, how on earth do these happen?');
                handleMouseUp(mousemoveEvent);
                return;
            }
            if (!dragStarted) {
                if (lastX === mousemoveEvent.clientX && lastY === mousemoveEvent.clientY) {
                    console.warn('Got a mouse move event with ', mousemoveEvent.clientX, ',', mousemoveEvent.clientY, ' when the last position was ', lastX, ',', lastY);
                }
                createAndFireCustomMouseEvent('grid-drag-start', downEvent, function (dragStart) {
                    var onlyFixedRows = !calculateRowScrollDiff(mousemoveEvent);
                    var onlyFixedCols = !calculateColScrollDiff(mousemoveEvent);
                    dragStart.enableAutoScroll = function () {
                        if (unbindAutoScrollDrag) {
                            unbindAutoScrollDrag();
                        }
                        unbindAutoScrollDrag = grid.eventLoop.bind('grid-drag', function (gridDragEvent) {
                            var newRowDiff = calculateRowScrollDiff(gridDragEvent);
                            onlyFixedRows = !newRowDiff;
                            var rowDiff = onlyFixedRows ? 0 : newRowDiff;
                            var newColDiff = calculateColScrollDiff;
                            onlyFixedCols = !newColDiff;
                            var colDiff = onlyFixedCols ? 0 : newColDiff(gridDragEvent);
                            if (scrollInterval != undefined) {
                                clearInterval(scrollInterval);
                            }
                            if (rowDiff || colDiff) {
                                scrollInterval = grid.interval(function () {
                                    grid.cellScrollModel.scrollTo(grid.cellScrollModel.row + rowDiff, grid.cellScrollModel.col + colDiff);
                                }, 100);
                            }
                        });
                    };
                });
                dragStarted = true;
            }
            createAndFireCustomMouseEvent('grid-drag', mousemoveEvent);
            if (mousemoveEvent.row !== lastDragRow || mousemoveEvent.col !== lastDragCol) {
                createAndFireCustomMouseEvent('grid-cell-drag', mousemoveEvent);
                lastDragRow = mousemoveEvent.row;
                lastDragCol = mousemoveEvent.col;
            }
        });
        var unbindUp = grid.eventLoop.bind(window, 'mouseup', handleMouseUp);
        function handleMouseUp(e) {
            if (scrollInterval != undefined) {
                clearInterval(scrollInterval);
            }
            unbindMove();
            unbindUp();
            if (unbindAutoScrollDrag) {
                unbindAutoScrollDrag();
            }
            var dragEnd = createCustomEventFromMouseEvent('grid-drag-end', e);
            grid.eventLoop.fire(dragEnd);
        }
    }
    function createCustomEventFromMouseEvent(type, e) {
        var event = custom_event_1.default(type, true, true);
        PROPS_TO_COPY_FROM_MOUSE_EVENTS.forEach(function (prop) {
            event[prop] = e[prop];
        });
        event.originalEvent = e;
        return event;
    }
    function createAndFireCustomMouseEvent(type, e, annotateEvent) {
        var drag = createCustomEventFromMouseEvent(type, e);
        if (annotateEvent) {
            drag = annotateEvent(drag) || drag;
        }
        if (e.target) {
            e.target.dispatchEvent(drag);
        }
        else {
            grid.eventLoop.fire(drag);
        }
        return drag;
    }
    return model;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function default_1(name, bubbles, cancelable, detail) {
    if (cancelable === void 0) { cancelable = false; }
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(name, bubbles, cancelable, detail);
    return event;
}
exports.default = default_1;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var dirty_clean_1 = __webpack_require__(1);
var util = __webpack_require__(0);
function create(grid) {
    var dirtyClean = dirty_clean_1.default(grid);
    function makeDimension(gridDimension) {
        function convertVirtualToScroll(virtualCoord) {
            return virtualCoord - gridDimension.rowColModel.numFixed();
        }
        function getScrollToRowOrCol(virtualCoord) {
            var currentScroll = cellScrollDimension.position;
            var scrollTo = currentScroll;
            if (gridDimension.viewPort.isInView(virtualCoord)) {
                return scrollTo;
            }
            var targetScroll = convertVirtualToScroll(virtualCoord);
            if (targetScroll < currentScroll) {
                scrollTo = targetScroll;
            }
            else if (targetScroll > currentScroll) {
                var lengthToCell = gridDimension.virtualPixelCell.sizeOf(0, virtualCoord);
                var numFixed = gridDimension.rowColModel.numFixed();
                scrollTo = 0;
                for (var i = numFixed; i < virtualCoord && lengthToCell > gridDimension.viewPort.size; i++) {
                    lengthToCell -= gridDimension.virtualPixelCell.sizeOf(i);
                    scrollTo = i - (numFixed - 1);
                }
            }
            return scrollTo;
        }
        var cellScrollDimension = {
            position: 0,
            scrollTo: function (position, dontFire) {
                var maxPosition = (gridDimension.rowColModel.length() || 1) - 1;
                var lastPosition = cellScrollDimension.position;
                cellScrollDimension.position = util.clamp(position, 0, maxPosition);
                if (lastPosition !== cellScrollDimension.position) {
                    dirtyClean.setDirty();
                    if (!dontFire) {
                        notifyListeners();
                    }
                    return true;
                }
                return false;
            },
            getPixelScroll: function () {
                return gridDimension.virtualPixelCell.sizeOf(gridDimension.rowColModel.numFixed(), cellScrollDimension.position + gridDimension.rowColModel.numFixed() - 1);
            },
            getScrollIntoViewCell: function (dataCell) {
                var virtualCell = gridDimension.converters.virtual.clamp(gridDimension.converters.data.toVirtual(dataCell));
                return getScrollToRowOrCol(virtualCell);
            }
        };
        return cellScrollDimension;
    }
    var model = {
        get col() {
            return model.colInfo.position;
        },
        get row() {
            return model.rowInfo.position;
        },
        isDirty: dirtyClean.isDirty,
        rowInfo: makeDimension(grid.rows),
        colInfo: makeDimension(grid.cols),
        scrollTo: function (r, c, dontFire, dontNotifyPixelModel) {
            if (isNaN(r) || isNaN(c)) {
                return;
            }
            var rowScrollChange = model.rowInfo.scrollTo(r, true);
            var colScrollChange = model.colInfo.scrollTo(c, true);
            if (rowScrollChange || colScrollChange) {
                if (!dontFire) {
                    notifyListeners(dontNotifyPixelModel);
                }
            }
        },
        scrollIntoView: function (dataRow, dataCol) {
            var newRow = model.rowInfo.getScrollIntoViewCell(dataRow);
            var newCol = model.colInfo.getScrollIntoViewCell(dataCol);
            model.scrollTo(newRow, newCol);
        }
    };
    function notifyListeners(dontNotifyPixelModel) {
        grid.eventLoop.fire('grid-cell-scroll');
        if (!dontNotifyPixelModel) {
            grid.pixelScrollModel.scrollTo(model.rowInfo.getPixelScroll(), model.colInfo.getPixelScroll(), true);
        }
    }
    grid.eventLoop.bind('grid-row-change', function (e) {
        switch (e.action) {
            case 'remove':
                model.scrollTo(0, model.col);
                break;
        }
    });
    return model;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var abstract_row_col_model_1 = __webpack_require__(9);
var ColModel = (function (_super) {
    __extends(ColModel, _super);
    function ColModel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.width = function (idx) {
            return _this.sizeOf(idx);
        };
        _this.col = function (idx) {
            return _this.get(idx, true);
        };
        return _this;
    }
    return ColModel;
}(abstract_row_col_model_1.AbstractRowColModel));
exports.ColModel = ColModel;
function create(grid) {
    return new ColModel(grid, 'col', 'width', 100);
}
exports.create = create;
exports.default = create;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ctrl_or_cmd_1 = __webpack_require__(19);
var event_loop_1 = __webpack_require__(2);
var util = __webpack_require__(0);
var elementClass = __webpack_require__(20);
function create(grid) {
    var wasSelectedAtMousedown;
    var model = {
        _dragRects: [],
        _onMousedown: function (e) {
            if (!isTargetingColHeader(e)) {
                return;
            }
            var colDescriptor = grid.data.col.get(e.col);
            wasSelectedAtMousedown = colDescriptor && !!colDescriptor.selected;
            if (wasSelectedAtMousedown && !ctrl_or_cmd_1.default(e)) {
                grid.eventLoop.stopBubbling(e);
            }
        },
        _onDragStart: function (e) {
            if (!isTargetingColHeader(e) || e.realCol < grid.colModel.numFixed() || !wasSelectedAtMousedown) {
                return;
            }
            var colDescriptor = grid.view.col.get(e.realCol);
            if (!colDescriptor || colDescriptor.selectable === false) {
                return;
            }
            if (e.enableAutoScroll) {
                e.enableAutoScroll();
            }
            grid.eventLoop.stopBubbling(e);
            var startCol = e.virtualCol;
            model._targetCol = grid.decorators.create(0, undefined, Infinity, 1, 'cell', 'real');
            model._targetCol.postRender = function (div) {
                div.setAttribute('class', 'grid-reorder-target');
                if (!model._targetCol) {
                    console.error('somehow targetCol was set back to undefined before post render');
                    return;
                }
                model._targetCol._renderedElem = div;
            };
            grid.decorators.add(model._targetCol);
            var selected = grid.colModel.getSelected();
            model._dragRects = selected.map(function (dataCol) {
                var viewCol = grid.data.col.toView(dataCol);
                var dragRect = grid.decorators.create(0, undefined, Infinity, undefined, 'px', 'real');
                dragRect.fixed = true;
                dragRect.colOffset = e.gridX - grid.viewPort.getColLeft(viewCol);
                dragRect.postRender = function (div) {
                    div.setAttribute('class', 'grid-drag-rect');
                };
                dragRect.width = grid.viewPort.getColWidth(viewCol);
                return dragRect;
            });
            grid.decorators.add(model._dragRects);
            model._unbindKeyDown = grid.escapeStack.add(removeDecoratorsAndUnbind);
            model._unbindDrag = grid.eventLoop.bind('grid-drag', function (gridDragEvent) {
                model._dragRects.forEach(function (dragRect) {
                    dragRect.left = util.clamp(gridDragEvent.gridX - dragRect.colOffset, grid.viewPort.getColLeft(grid.colModel.numFixed()), Infinity);
                });
                if (!model._targetCol) {
                    console.error('somehow targetCol was set back to undefined before drag');
                    return;
                }
                model._targetCol.left = util.clamp(gridDragEvent.realCol, grid.colModel.numFixed(), Infinity);
                model._targetCol.moveAfter = gridDragEvent.realCol > startCol;
                if (model._targetCol.moveAfter) {
                    elementClass(model._targetCol._renderedElem).add('right');
                }
                else {
                    elementClass(model._targetCol._renderedElem).remove('right');
                }
            });
            model._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function () {
                if (!model._targetCol) {
                    console.error('somehow targetCol was set to undefined before drag end');
                    return;
                }
                var targetDataCol = model._targetCol.left;
                if (targetDataCol !== undefined) {
                    grid.colModel.move(selected.map(function (dataCol) {
                        return grid.data.col.toVirtual(dataCol);
                    }), grid.viewPort.toVirtualCol(targetDataCol), model._targetCol.moveAfter);
                }
                removeDecoratorsAndUnbind();
            });
            function removeDecoratorsAndUnbind() {
                if (model._targetCol) {
                    var removedDecs = model._dragRects.concat([model._targetCol]);
                    grid.decorators.remove(removedDecs);
                }
                if (model._unbindDrag) {
                    model._unbindDrag();
                }
                if (model._unbindDragEnd) {
                    model._unbindDragEnd();
                }
                if (model._unbindKeyDown) {
                    model._unbindKeyDown();
                }
                return true;
            }
        }
    };
    function isTargetingColHeader(e) {
        return e && e.row < 0;
    }
    grid.eventLoop.bind('grid-drag-start', model._onDragStart);
    grid.eventLoop.addInterceptor(function (e) {
        if (event_loop_1.isAnnotatedMouseEventOfType(e, 'mousedown')) {
            model._onMousedown(e);
        }
    });
    return model;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function default_1(e) {
    return (window.navigator.userAgent.match(/win/i) ? e.ctrlKey : e.metaKey);
}
exports.default = default_1;


/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = function(opts) {
  return new ElementClass(opts)
}

function ElementClass(opts) {
  if (!(this instanceof ElementClass)) return new ElementClass(opts)
  var self = this
  if (!opts) opts = {}

  // similar doing instanceof HTMLElement but works in IE8
  if (opts.nodeType) opts = {el: opts}

  this.opts = opts
  this.el = opts.el || document.body
  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)
}

ElementClass.prototype.add = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return el.className = className
  var classes = el.className.split(' ')
  if (classes.indexOf(className) > -1) return classes
  classes.push(className)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.remove = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return
  var classes = el.className.split(' ')
  var idx = classes.indexOf(className)
  if (idx > -1) classes.splice(idx, 1)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.has = function(className) {
  var el = this.el
  if (!el) return
  var classes = el.className.split(' ')
  return classes.indexOf(className) > -1
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var header_decorators_1 = __webpack_require__(43);
function create(grid) {
    var api = {
        annotateDecorator: annotateDecorator
    };
    function annotateDecorator(headerDecorator) {
        var col = headerDecorator.left;
        headerDecorator._dragLine = grid.decorators.create(0, undefined, Infinity, 1, 'px', 'real');
        headerDecorator._dragLine.fixed = true;
        headerDecorator._dragLine.postRender = function (div) {
            div.setAttribute('class', 'grid-drag-line');
        };
        headerDecorator._onMousedown = function (e) {
            grid.eventLoop.stopBubbling(e);
        };
        headerDecorator._onDragStart = function (e) {
            grid.eventLoop.stopBubbling(e);
            grid.decorators.add(headerDecorator._dragLine);
            headerDecorator._unbindDrag = grid.eventLoop.bind('grid-drag', function (gridDragEvent) {
                var minX = headerDecorator.getDecoratorLeft() + 22;
                headerDecorator._dragLine.left = Math.max(gridDragEvent.gridX, minX);
            });
            headerDecorator._unbindKeyDown = grid.escapeStack.add(removeDecoratorsAndUnbind);
            headerDecorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function () {
                var dragLeft = headerDecorator._dragLine.left;
                if (dragLeft !== undefined && col !== undefined) {
                    var newWidth_1 = dragLeft - headerDecorator.getDecoratorLeft();
                    grid.view.col.get(col).width = newWidth_1;
                    grid.colModel.getSelected().forEach(function (dataIdx) {
                        grid.data.col.get(dataIdx).width = newWidth_1;
                    });
                }
                removeDecoratorsAndUnbind();
            });
            function removeDecoratorsAndUnbind() {
                grid.decorators.remove(headerDecorator._dragLine);
                if (headerDecorator._unbindDrag) {
                    headerDecorator._unbindDrag();
                }
                if (headerDecorator._unbindDragEnd) {
                    headerDecorator._unbindDragEnd();
                }
                if (headerDecorator._unbindKeyDown) {
                    headerDecorator._unbindKeyDown();
                }
                return true;
            }
        };
        headerDecorator.postRender = function (div) {
            div.style.transform = 'translateX(50%)';
            div.style.webkitTransform = 'translateX(50%)';
            div.style.removeProperty('left');
            div.setAttribute('class', 'col-resize');
            div.setAttribute('dts', 'grid_header_resize');
            grid.eventLoop.bind(div, 'grid-drag-start', headerDecorator._onDragStart);
            grid.eventLoop.bind(div, 'mousedown', headerDecorator._onMousedown);
        };
    }
    header_decorators_1.default(grid, api);
    return api;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var debounce_1 = __webpack_require__(6);
var tsv = __webpack_require__(44);
var innerText = __webpack_require__(45);
function create(grid) {
    function getCopyPasteRange() {
        var selectionRange = grid.navigationModel.selection;
        if (selectionRange.top === -1) {
            selectionRange = {
                top: grid.navigationModel.focus.row,
                left: grid.navigationModel.focus.col,
                width: 1,
                height: 1
            };
        }
        return selectionRange;
    }
    grid.eventLoop.bind('copy', function (e) {
        if (!grid.focused) {
            if (e.target === grid.textarea) {
                e.preventDefault();
            }
            return;
        }
        var copyTable = document.createElement('table');
        var tableBody = document.createElement('tbody');
        copyTable.appendChild(tableBody);
        var tsvData = [];
        var selectionRange = getCopyPasteRange();
        var gotNull = false;
        grid.data.iterate(selectionRange, function () {
            var row = document.createElement('tr');
            tableBody.appendChild(row);
            var array = [];
            tsvData.push(array);
            return {
                row: row,
                array: array
            };
        }, function (r, c, rowResult) {
            var data = grid.dataModel.get(r, c, true);
            if (data == null) {
                return gotNull = true;
            }
            var td = document.createElement('td');
            if (data.value) {
                td.setAttribute('grid-data', JSON.stringify(data.value));
            }
            td.textContent = data.formatted || ' ';
            td.innerHTML = td.innerHTML.replace(/\n/g, '<br>') || ' ';
            rowResult.row.appendChild(td);
            rowResult.array.push(data.formatted);
            return undefined;
        });
        if (!gotNull) {
            e.clipboardData.setData('text/plain', tsv.stringify(tsvData));
            e.clipboardData.setData('text/html', copyTable.outerHTML);
            e.preventDefault();
            setTimeout(function () {
                grid.eventLoop.fire('grid-copy');
            }, 1);
        }
    });
    function makePasteDataChange(r, c, data) {
        var value;
        var formatted;
        if (typeof data === 'string') {
            formatted = data;
        }
        else {
            value = data.value;
            formatted = data.formatted;
        }
        return {
            row: r,
            col: c,
            value: value,
            formatted: formatted,
            paste: true
        };
    }
    grid.eventLoop.bind('paste', function (e) {
        if (!grid.focused) {
            return;
        }
        var selectionRange = getCopyPasteRange();
        if (!e.clipboardData || !e.clipboardData.getData) {
            console.warn('no clipboard data on paste event');
            return;
        }
        var tsvPasteData = tsv.parse(e.clipboardData.getData('text/plain'));
        var pasteHtml = e.clipboardData.getData('text/html');
        e.preventDefault();
        setTimeout(function () {
            var tempDiv = document.createElement('div');
            if (pasteHtml.match(/<meta name=ProgId content=Excel.Sheet>/)) {
                pasteHtml = pasteHtml.replace(/[\n\r]+  /g, ' ').replace(/[\n\r]+/g, '');
            }
            tempDiv.innerHTML = pasteHtml;
            var table = tempDiv.querySelector('table');
            var pasteData = tsvPasteData;
            if (table) {
                var tablePasteData_1;
                table.style.whiteSpace = 'pre';
                tablePasteData_1 = [];
                var trs_1 = tempDiv.querySelectorAll('tr');
                [].forEach.call(trs_1, function (tr) {
                    var row = [];
                    tablePasteData_1.push(row);
                    var tds = tr.querySelectorAll('td');
                    [].forEach.call(tds, function (td) {
                        var text = innerText(td);
                        var dataResult = {
                            formatted: text && text.trim(),
                            value: undefined
                        };
                        var gridData = td.getAttribute('grid-data');
                        if (gridData) {
                            try {
                                dataResult.value = JSON.parse(gridData);
                            }
                            catch (error) {
                                console.warn('somehow couldn\'t parse grid data');
                            }
                        }
                        row.push(dataResult);
                    });
                });
                pasteData = tablePasteData_1;
            }
            var dataChanges = [];
            var singlePasteValue;
            if (pasteData.length === 1 && pasteData[0].length === 1) {
                singlePasteValue = pasteData[0][0];
            }
            if (singlePasteValue) {
                var singlePasteString_1 = singlePasteValue;
                var ranges = [selectionRange];
                ranges = ranges.concat(grid.navigationModel.otherSelections);
                ranges.forEach(function (range) {
                    grid.data.iterate(range, function (r, c) {
                        dataChanges.push(makePasteDataChange(r, c, singlePasteString_1));
                    });
                });
            }
            else {
                var top_1 = selectionRange.top;
                var left_1 = selectionRange.left;
                pasteData.forEach(function (row, r) {
                    var dataRow = r + top_1;
                    if (dataRow > grid.data.row.count() - 1) {
                        return;
                    }
                    row.forEach(function (pasteValue, c) {
                        var dataCol = c + left_1;
                        if (pasteValue == undefined || dataCol > grid.data.col.count() - 1) {
                            return;
                        }
                        dataChanges.push(makePasteDataChange(dataRow, dataCol, pasteValue));
                    });
                });
                var newSelection = {
                    top: top_1,
                    left: left_1,
                    height: pasteData.length,
                    width: pasteData[0].length
                };
                grid.navigationModel.clearSelection();
                grid.navigationModel.setSelection(newSelection);
            }
            grid.dataModel.set(dataChanges);
        }, 1);
    });
    var maybeSelectText = debounce_1.default(function maybeSelectTextInner() {
        if (!(grid.editModel && grid.editModel.editing) && grid.focused) {
            grid.textarea.value = grid.dataModel.get(grid.navigationModel.focus.row, grid.navigationModel.focus.col).formatted || '.';
            grid.textarea.select();
        }
    }, 1);
    grid.eventLoop.bind('keyup', function (_e) {
        maybeSelectText();
    });
    grid.eventLoop.bind('grid-focus', function (_e) {
        maybeSelectText();
    });
    grid.eventLoop.bind('mousedown', function (e) {
        if (e.target !== grid.textarea) {
            return;
        }
        maybeSelectText();
    });
    return {
        _maybeSelectText: maybeSelectText
    };
}
exports.create = create;
exports.default = create;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var dirty_clean_1 = __webpack_require__(1);
var position_range_1 = __webpack_require__(5);
var util = __webpack_require__(0);
function create(grid) {
    var dirtyClean = dirty_clean_1.default(grid);
    var aliveDecorators = [];
    var deadDecorators = [];
    var decoratorsInstance = {
        add: function (_decorators) {
            var decorators = util.toArray(_decorators);
            decorators.forEach(function (decorator) {
                aliveDecorators.push(decorator);
                if (decorator._decoratorDirtyClean) {
                    decorator._decoratorDirtyClean.enable();
                }
            });
            dirtyClean.setDirty();
        },
        remove: function (_decorators) {
            var decorators = util.toArray(_decorators);
            decorators.forEach(function (decorator) {
                var index = aliveDecorators.indexOf(decorator);
                if (index !== -1) {
                    aliveDecorators.splice(index, 1);
                    deadDecorators.push(decorator);
                    if (decorator._decoratorDirtyClean) {
                        decorator._decoratorDirtyClean.disable();
                    }
                    dirtyClean.setDirty();
                }
            });
        },
        getAlive: function () {
            return aliveDecorators.slice(0);
        },
        popAllDead: function () {
            var oldDead = deadDecorators;
            deadDecorators = [];
            return oldDead;
        },
        isDirty: dirtyClean.isDirty,
        create: function (t, l, h, w, u, s) {
            var thisDirtyClean = dirty_clean_1.default(grid);
            var decoratorBase = {
                _decoratorDirtyClean: thisDirtyClean,
                render: function () {
                    var div = document.createElement('div');
                    div.style.position = 'absolute';
                    div.style.top = '0px';
                    div.style.left = '0px';
                    div.style.bottom = '0px';
                    div.style.right = '0px';
                    if (decorator.postRender) {
                        decorator.postRender(div);
                    }
                    return div;
                }
            };
            var decorator = position_range_1.default(decoratorBase, thisDirtyClean, dirtyClean);
            decorator.top = t;
            decorator.left = l;
            decorator.height = h;
            decorator.width = w;
            decorator.units = u || decorator.units;
            decorator.space = s || decorator.space;
            return decorator;
        }
    };
    return decoratorsInstance;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var event_loop_1 = __webpack_require__(2);
var key = __webpack_require__(25);
var clickOff = __webpack_require__(51);
var Trigger;
(function (Trigger) {
    Trigger["Click"] = "click";
    Trigger["Space"] = "space";
    Trigger["Enter"] = "enter";
    Trigger["Dblclick"] = "dblclick";
    Trigger["Typing"] = "typing";
    Trigger["Tab"] = "tab";
    Trigger["Clickoff"] = "clickoff";
    Trigger["Escape"] = "escape";
})(Trigger = exports.Trigger || (exports.Trigger = {}));
function create(grid) {
    var editModel = {
        editing: false,
        _defaultDecorator: grid.decorators.create(-1, -1, 1, 1),
        _hydrateOpts: function (optsCreator) {
            if (optsCreator === void 0) { optsCreator = {}; }
            var isActionMode = !!(optsCreator && optsCreator.action);
            var opts = __assign({ getEditor: function () {
                    return {};
                }, headers: !!optsCreator.headers, editTriggers: isActionMode ?
                    [Trigger.Click, Trigger.Space, Trigger.Enter] :
                    [Trigger.Dblclick, Trigger.Enter, Trigger.Typing], saveTriggers: isActionMode ?
                    [] :
                    [Trigger.Tab, Trigger.Enter, Trigger.Clickoff], cancelTriggers: isActionMode ?
                    [] :
                    [Trigger.Escape] }, optsCreator);
            if (isActionMode) {
                opts.getEditor = function () {
                    return {
                        decorator: false,
                        save: undefined,
                        closePromise: opts.action && opts.action.apply(opts, arguments)
                    };
                };
            }
            else if (!opts.getEditor) {
                opts.getEditor = function () {
                    return {};
                };
            }
            return opts;
        },
        _interceptor: function (e) {
            if (!event_loop_1.isAnnotatedMouseOrKeyEvent(e)) {
                return;
            }
            var col = e.col;
            var row = e.row;
            var opts = getOptsForCol(col);
            if (!opts) {
                return;
            }
            if (!editModel.editing) {
                switch (e.type) {
                    case 'click':
                        if (optsHasEditTrigger(opts, Trigger.Click) && grid.eventIsOnCells(e)) {
                            editModel.editCell(row, col, false, e);
                        }
                        break;
                    case 'dblclick':
                        if (optsHasEditTrigger(opts, Trigger.Dblclick) && grid.eventIsOnCells(e)) {
                            editModel.editCell(row, col, false, e);
                        }
                        break;
                    case 'keydown':
                        if (optsHasEditTrigger(opts, Trigger.Space) && key.is(key.code.special.space, e.which)) {
                            editModel.editCell(row, col, false, e);
                        }
                        if (optsHasEditTrigger(opts, Trigger.Enter) && key.is(key.code.special.enter, e.which)) {
                            editModel.editCell(row, col, false, e);
                        }
                        if (key.is(key.code.special.backspace, e.which) || e.which === 46) {
                            editModel.deleteSelection();
                        }
                        break;
                    case 'keypress':
                        if (optsHasEditTrigger(opts, Trigger.Typing) &&
                            e.which >= 32 && e.which <= 122 && !e.metaKey && !e.ctrlKey && !e.altKey) {
                            editModel.editCell(row, col, true, e);
                        }
                        break;
                }
            }
            else {
                switch (e.type) {
                    case 'keydown':
                        if (optsHasSaveTrigger(opts, Trigger.Tab) && key.is(key.code.special.tab, e.which)) {
                            editModel.saveEdit().then(function () {
                                grid.navigationModel.handleTabEvent(e);
                            });
                            e.preventDefault();
                        }
                        if (optsHasSaveTrigger(opts, Trigger.Enter) && key.is(key.code.special.enter, e.which) && !e.shiftKey) {
                            editModel.saveEdit().then(function () {
                                grid.navigationModel.setFocus(grid.data.down(grid.navigationModel.focus.row), grid.navigationModel.focus.col);
                            });
                        }
                        break;
                }
            }
        },
        deleteSelection: function () {
            var ranges = grid.navigationModel.getAllSelectedRanges();
            var dataChanges = [];
            ranges.forEach(function (range) {
                grid.data.iterate(range, function (r, c) {
                    dataChanges.push({
                        row: r,
                        col: c,
                        value: undefined
                    });
                });
            });
            grid.dataModel.set(dataChanges);
        },
        editCell: function (r, c, isTyping, originalEvent) {
            if (editModel.editing) {
                editModel.saveEdit();
            }
            editModel.savePromise = undefined;
            if (isNaN(r) || isNaN(c)) {
                return;
            }
            var opts = getOptsForCol(c);
            if (!opts) {
                return;
            }
            if ((r < 0 || c < 0) && !opts.headers) {
                return;
            }
            var editor = opts.getEditor(r, originalEvent);
            if (!editor || (!editor.closePromise && editor.decorator === false)) {
                return;
            }
            setEditing(true);
            if (editor.decorator === undefined) {
                editor.decorator = editModel._defaultDecorator;
                if (editor.save === undefined) {
                    editor.save = function () {
                        var text = editModel._defaultDecorator.renderedElem && editModel._defaultDecorator.renderedElem.value;
                        return Promise.resolve({
                            value: text,
                            formatted: text
                        });
                    };
                }
            }
            editModel.currentEditor = editor;
            if (editor.decorator) {
                editor.decorator.typedText = function () {
                    return isTyping ? grid.textarea.value && grid.textarea.value.trim() : '';
                };
                editor.decorator.top = r;
                editor.decorator.left = c;
                grid.decorators.add(editor.decorator);
                editor.removeEscapeStackHandler = grid.escapeStack.add(function () {
                    if (optsHasCancelTrigger(opts, Trigger.Escape)) {
                        editModel.cancelEdit();
                    }
                    else if (optsHasSaveTrigger(opts, Trigger.Escape)) {
                        editModel.saveEdit();
                    }
                });
                editor.removeClickOffHandler = clickOff.listen(function getClickOffElement() {
                    return editor.decorator && editor.decorator.boundingBox;
                }, function (e) {
                    if (editor.isInMe && editor.isInMe(e)) {
                        return;
                    }
                    if (optsHasCancelTrigger(opts, Trigger.Clickoff)) {
                        editModel.cancelEdit();
                    }
                    else if (optsHasSaveTrigger(opts, Trigger.Clickoff)) {
                        editModel.saveEdit();
                    }
                }, {});
            }
            if (editor.closePromise) {
                editor.closePromise.then(function resolved() {
                    return editModel.saveEdit();
                }, function rejected() {
                    return editModel.cancelEdit();
                });
            }
        },
        _closeEditor: function () {
            if (!editModel.editing) {
                return;
            }
            setEditing(false);
            var currentEditor = editModel.currentEditor;
            if (currentEditor) {
                if (currentEditor.removeEscapeStackHandler) {
                    currentEditor.removeEscapeStackHandler();
                }
                if (currentEditor.removeClickOffHandler) {
                    currentEditor.removeClickOffHandler();
                }
                if (currentEditor.decorator) {
                    grid.decorators.remove(currentEditor.decorator);
                }
            }
            grid.viewLayer.draw();
            grid.eventLoop.bindOnce('grid-draw', function () {
                if (grid.container) {
                    grid.container.focus();
                }
            });
        },
        cancelEdit: function () {
            editModel._closeEditor();
        },
        saveEdit: function () {
            if (!editModel.savePromise) {
                var currentEditor = editModel.currentEditor;
                var savePromise = currentEditor && currentEditor.save && currentEditor.save();
                var maybeSetPromise = savePromise && savePromise.then(function (dataResult) {
                    if (dataResult) {
                        if (editModel.currentEditor && editModel.currentEditor.decorator) {
                            var _a = editModel.currentEditor.decorator, top_1 = _a.top, left = _a.left;
                            if (top_1 !== undefined && left !== undefined) {
                                dataResult.row = top_1;
                                dataResult.col = left;
                                grid.dataModel.set([dataResult]);
                            }
                        }
                    }
                    return dataResult;
                }) || Promise.resolve();
                editModel.savePromise = maybeSetPromise.then(function (result) {
                    editModel._closeEditor();
                    return result;
                });
            }
            return editModel.savePromise;
        },
    };
    editModel._defaultDecorator.render = function () {
        var element = document.createElement('textarea');
        element.style.pointerEvents = 'all';
        element.style.zIndex = '1';
        element.style.position = 'relative';
        grid.eventLoop.bindOnce('grid-draw', function () {
            var top = editModel._defaultDecorator.top;
            var left = editModel._defaultDecorator.left;
            element.value = editModel._defaultDecorator.typedText && editModel._defaultDecorator.typedText() ||
                (top != undefined && left != undefined && grid.dataModel.get(top, left).formatted) ||
                '';
            element.focus();
        });
        editModel._defaultDecorator.renderedElem = element;
        return element;
    };
    function hasTrigger(trigger, triggers) {
        return triggers.indexOf(trigger) !== -1;
    }
    function optsHasEditTrigger(opts, trigger) {
        return hasTrigger(trigger, opts.editTriggers);
    }
    function optsHasCancelTrigger(opts, trigger) {
        return hasTrigger(trigger, opts.cancelTriggers);
    }
    function optsHasSaveTrigger(opts, trigger) {
        return hasTrigger(trigger, opts.saveTriggers);
    }
    function getOptsForCol(col) {
        var colDescriptor = grid.data.col.get(col);
        if (!colDescriptor) {
            return;
        }
        return editModel._hydrateOpts(colDescriptor.editOptions);
    }
    function setEditing(editing) {
        var prevEditing = editModel.editing;
        editModel.editing = editing;
        if (prevEditing !== editing) {
            grid.eventLoop.fire('grid-edit');
        }
    }
    grid.eventLoop.bind('grid-destroy', function () {
        editModel.cancelEdit();
    });
    grid.eventLoop.addInterceptor(editModel._interceptor);
    return editModel;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var isRef, iterator, key,
    _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  isRef = __webpack_require__(3).isRef;

  key = {};

  key.code = {
    special: __webpack_require__(46),
    arrow: __webpack_require__(47),
    punctuation: __webpack_require__(48),
    alnum: __webpack_require__(49),
    brand: __webpack_require__(50)
  };

  key.get = function(pressed) {
    return iterator(key.code, pressed);
  };

  key.is = function(ref, pressed) {
    if (!isRef(ref)) {
      ref = iterator(ref, pressed);
    }
    if (isRef(ref)) {
      if (isRef(pressed)) {
        return pressed === ref;
      } else {
        return pressed === ref.code || __indexOf.call(ref.code, pressed) >= 0;
      }
    } else {
      return pressed === ref;
    }
  };

  iterator = function(context, pressed) {
    var i, out, ref;
    for (i in context) {
      if (!__hasProp.call(context, i)) continue;
      ref = context[i];
      if (isRef(ref)) {
        if (key.is(ref, pressed)) {
          return ref;
        }
      } else {
        out = iterator(ref, pressed);
        if (isRef(out)) {
          return out;
        }
      }
    }
  };

  if (typeof window !== 'undefined') {
    window.key = key;
  }

  module.exports = key;

}).call(this);


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var timeNow = __webpack_require__(52);
function create(grid) {
    var frames = [];
    var totalTime = 0;
    var totalFrames = 0;
    var totalWindowTime = 0;
    var lastLoopTime;
    var filteredFrameTime = 0;
    var filterStrength = 20;
    var belowThresholdCount = 0;
    var numCalcs = 0;
    var filteredAverage;
    var requestId;
    function addFrameToWindow(frameLength) {
        if (typeof frameLength !== 'number' || isNaN(frameLength)) {
            console.warn('passed non number to fps.addFrame()');
            return;
        }
        if (frames.length > fps.windowSize) {
            var frame = frames.shift();
            if (frame !== undefined) {
                totalWindowTime -= frame;
            }
        }
        totalWindowTime += frameLength;
        totalTime += frameLength;
        totalFrames++;
        frames.push(frameLength);
    }
    grid.eventLoop.bind('grid-destroy', function () {
        if (requestId) {
            cancelAnimationFrame(requestId);
            requestId = undefined;
        }
    });
    var fps = {
        threshold: 20,
        windowSize: 60,
        slowCount: 0,
        logging: false,
        allAverages: false,
        markFrameTime: function () {
            var nowTime = timeNow();
            if (lastLoopTime) {
                var frameLength = nowTime - lastLoopTime;
                filteredFrameTime += (frameLength - filteredFrameTime) / filterStrength;
                filteredAverage = 1000 / filteredFrameTime;
                if (filteredAverage < fps.threshold) {
                    belowThresholdCount++;
                }
                if (fps.allAverages) {
                    addFrameToWindow(1000 / frameLength);
                }
                numCalcs++;
            }
            lastLoopTime = nowTime;
        },
        getMovingAverage: function () {
            return totalWindowTime / frames.length;
        },
        getAllTimeAverage: function () {
            return totalTime / totalFrames;
        },
        getLast: function () {
            return frames[frames.length - 1];
        },
        getFilteredAverage: function () {
            return filteredAverage;
        },
        intervalId: window.setInterval(function () {
            fps.percentBelowThreshold = belowThresholdCount / numCalcs * 100;
            if (fps.percentBelowThreshold > 50) {
                fps.slowCount++;
            }
            if (fps.logging) {
                console.log('percent below threshold', fps.percentBelowThreshold.toFixed(1), 'filtered average', fps.getFilteredAverage());
            }
            belowThresholdCount = 0;
            numCalcs = 0;
        }, 1000)
    };
    function fpsMeasure() {
        if (grid.destroyed) {
            return;
        }
        requestId = requestAnimationFrame(fpsMeasure);
        fps.markFrameTime();
    }
    fpsMeasure();
    return fps;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ctrl_or_cmd_1 = __webpack_require__(19);
var rangeUtil = __webpack_require__(11);
var util = __webpack_require__(0);
var key = __webpack_require__(25);
var arrow = key.code.arrow;
function create(grid) {
    var mainSelection = createAndAddSelectionDecorator(0, 0, -1, -1);
    var model = {
        focus: {
            row: 0,
            col: 0
        },
        get selection() {
            if (mainSelection.height === -1) {
                return {
                    top: model.focus.row,
                    left: model.focus.col,
                    height: 1,
                    width: 1
                };
            }
            return mainSelection;
        },
        otherSelections: [],
        checkboxModeFor: {},
        _selectionDecorator: mainSelection,
        focusDecorator: grid.decorators.create(0, 0, 1, 1),
        _rowSelectionClasses: [],
        _colSelectionClasses: [],
        getAllSelections: function () {
            var selections = [];
            if (model.selection) {
                selections.push(model.selection);
            }
            return selections.concat(model.otherSelections);
        },
        setFocus: function (inputRow, inputCol, dontClearSelection, dontSetSelection) {
            inputRow = inputRow && grid.data.row.clamp(inputRow);
            var row = (typeof inputRow !== 'number' || isNaN(inputRow)) ? model.focus.row : inputRow;
            inputCol = inputCol && grid.data.col.clamp(inputCol);
            var col = (typeof inputCol !== 'number' || isNaN(inputCol)) ? model.focus.row : inputCol;
            var changed = row !== model.focus.row || col !== model.focus.col;
            model.focus.row = row;
            model.focus.col = col;
            focusClass.top = row;
            focusClass.left = col;
            model.focusDecorator.top = row;
            model.focusDecorator.left = col;
            grid.cellScrollModel.scrollIntoView(row, col);
            if (!dontClearSelection) {
                clearOtherSelections();
            }
            if (!dontSetSelection) {
                setSelectionToFocus();
            }
            if (changed) {
                grid.eventLoop.fire('grid-focus-change');
            }
        },
        _navFrom: navFrom,
        handleTabEvent: function (e) {
            var newCol = model.focus.col;
            var newRow = model.focus.row;
            if (!e || !e.shiftKey) {
                if (newCol === grid.data.col.count() - 1) {
                    newRow = grid.data.down(newRow);
                    newCol = 0;
                }
                else {
                    newCol = grid.data.right(newCol);
                }
            }
            else {
                if (newCol === 0) {
                    newRow = grid.data.up(newRow);
                    newCol = grid.data.col.count() - 1;
                }
                else {
                    newCol = grid.data.left(newCol);
                }
            }
            model.setFocus(newRow, newCol);
            e.preventDefault();
        },
        setSelection: function (newSelection) {
            var height = newSelection.height;
            var width = newSelection.width;
            if (selectionIsFocus(newSelection)) {
                height = -1;
                width = -1;
            }
            mainSelection.top = newSelection.top;
            mainSelection.left = newSelection.left;
            mainSelection.height = height;
            mainSelection.width = width;
            syncSelectionToHeaders();
        },
        getAllSelectedRanges: function () {
            var selectionRange = grid.navigationModel.selection;
            if (selectionRange.top === -1) {
                selectionRange = {
                    top: grid.navigationModel.focus.row,
                    left: grid.navigationModel.focus.col,
                    width: 1,
                    height: 1
                };
            }
            return [selectionRange].concat(model.otherSelections);
        },
        clearSelection: function () {
            clearOtherSelections();
            setSelectionToFocus();
        },
    };
    var focusClass = grid.cellClasses.create(0, 0, 'focus');
    grid.cellClasses.add(focusClass);
    model.focusDecorator.postRender = function (div) {
        div.setAttribute('class', 'grid-focus-decorator');
        return div;
    };
    grid.decorators.add(model.focusDecorator);
    function seekNextEdge(newIndex, startedDefined, isForwardEdge, isBackwardEdge, goForward) {
        var isEdgeToSeek = (isForwardEdge(newIndex) || !startedDefined) &&
            isBackwardEdge ||
            isForwardEdge;
        while (newIndex !== undefined && goForward(newIndex) !== undefined && !isEdgeToSeek(newIndex = goForward(newIndex))) {
        }
        return newIndex;
    }
    function navFrom(row, col, e) {
        var newRow = row;
        var newCol = col;
        var isSeek = ctrl_or_cmd_1.default(e);
        if (isSeek) {
            var cellHasValue_1 = function (r, c) {
                if (r === undefined || c === undefined) {
                    return false;
                }
                return !!grid.dataModel.get(r, c).formatted;
            };
            var isLeftwardEdge = function (c) {
                return cellHasValue_1(newRow, c) && !cellHasValue_1(newRow, grid.data.left(c));
            };
            var isRightwardEdge = function (c) {
                return cellHasValue_1(newRow, c) && !cellHasValue_1(newRow, grid.data.right(c));
            };
            var isUpwardEdge = function (r) {
                return cellHasValue_1(r, newCol) && !cellHasValue_1(grid.data.up(r), newCol);
            };
            var isDownwardEdge = function (r) {
                return cellHasValue_1(r, newCol) && !cellHasValue_1(grid.data.down(r), newCol);
            };
            var startedDefined = cellHasValue_1(newRow, newCol);
            switch (e.which) {
                case arrow.down.code:
                    newRow = seekNextEdge(newRow, startedDefined, isDownwardEdge, isUpwardEdge, grid.data.down);
                    break;
                case arrow.up.code:
                    newRow = seekNextEdge(newRow, startedDefined, isUpwardEdge, isDownwardEdge, grid.data.up);
                    break;
                case arrow.right.code:
                    newCol = seekNextEdge(newCol, startedDefined, isRightwardEdge, isLeftwardEdge, grid.data.right);
                    break;
                case arrow.left.code:
                    newCol = seekNextEdge(newCol, startedDefined, isLeftwardEdge, isRightwardEdge, grid.data.left);
                    break;
            }
        }
        else {
            switch (e.which) {
                case arrow.down.code:
                    newRow = grid.data.down(newRow);
                    break;
                case arrow.up.code:
                    newRow = grid.data.up(newRow);
                    break;
                case arrow.right.code:
                    newCol = grid.data.right(newCol);
                    break;
                case arrow.left.code:
                    newCol = grid.data.left(newCol);
                    break;
            }
        }
        if (newRow === undefined) {
            newRow = row;
        }
        if (newCol === undefined) {
            newCol = col;
        }
        return {
            row: newRow,
            col: newCol
        };
    }
    grid.eventLoop.bind('keydown', function (e) {
        if (!grid.focused) {
            return;
        }
        if (key.is(key.code.special.tab, e.which)) {
            model.handleTabEvent(e);
            return;
        }
        if (!key.is(arrow, e.which)) {
            return;
        }
        if (!e.shiftKey) {
            var newFocus = navFrom(model.focus.row, model.focus.col, e);
            model.setFocus(newFocus.row, newFocus.col, true);
        }
        else {
            var newSelection = void 0;
            if (model.selection.top === -1) {
                newSelection = {
                    top: model.focus.row,
                    left: model.focus.col,
                    height: 1,
                    width: 1
                };
            }
            else {
                newSelection = {
                    top: model.selection.top,
                    left: model.selection.left,
                    height: model.selection.height,
                    width: model.selection.width
                };
            }
            var navFromRow = (model.focus.row === newSelection.top) ?
                newSelection.top + newSelection.height - 1 :
                newSelection.top;
            var navFromCol = (model.focus.col === newSelection.left) ?
                newSelection.left + newSelection.width - 1 :
                newSelection.left;
            var newRowCol = navFrom(navFromRow, navFromCol, e);
            setSelectionFromPoints(model.focus.row, model.focus.col, newRowCol.row, newRowCol.col);
            grid.cellScrollModel.scrollIntoView(newRowCol.row, newRowCol.col);
        }
    });
    function isNavableMouseEvent(e) {
        var target = e.target;
        return !target || grid.eventIsOnCells(e) && e.button !== 2;
    }
    function isCheckboxModeForRowCol(row, col) {
        return model.checkboxModeFor.rows && col < 0 || (row < 0 && colSelectable(col)) && model.checkboxModeFor.cols;
    }
    grid.eventLoop.bind('mousedown', function (e) {
        if (!isNavableMouseEvent(e)) {
            return;
        }
        var row = e.row;
        var col = e.col;
        var isCheckboxMode = isCheckboxModeForRowCol(row, col);
        var ctrlOrCmdPressed = isCheckboxMode || ctrl_or_cmd_1.default(e);
        if (e.shiftKey) {
            var fromRow = model.focus.row;
            var fromCol = model.focus.col;
            var toRow = row;
            var toCol = col;
            var wasSelected = void 0;
            if (toRow < 0) {
                var colDescriptor = grid.data.col.get(toCol);
                if (colDescriptor.selectable !== false) {
                    wasSelected = colDescriptor.selected;
                    fromRow = 0;
                    toRow = Infinity;
                }
            }
            if (toCol < 0) {
                wasSelected = grid.data.row.get(toRow).selected;
                fromCol = 0;
                toCol = Infinity;
            }
            selectFromFocusToCell(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed, wasSelected);
        }
        else {
            var focusRow = row;
            if (focusRow < 0) {
                focusRow = grid.view.row.toData(grid.rowModel.numHeaders());
            }
            var focusCol = col;
            if (focusCol < 0) {
                focusCol = grid.view.col.toData(grid.colModel.numHeaders());
            }
            var headerSelectionRange_1 = createHeaderSelectionRange(row, col);
            if (headerSelectionRange_1) {
                var prevSelections = findFullRowOrColSelections(headerSelectionRange_1);
                if (prevSelections.length && isCheckboxMode) {
                    var selectAll = headerSelectionRange_1.width === Infinity &&
                        headerSelectionRange_1.height === Infinity &&
                        !(grid.rowModel.allSelected() || grid.colModel.allSelected());
                    prevSelections.forEach(function (prevSelection) {
                        removeFullRowOrColFromSelection(prevSelection, headerSelectionRange_1);
                    });
                    if (selectAll) {
                        model.setSelection(headerSelectionRange_1);
                    }
                    model.setFocus(focusRow, focusCol, true, true);
                }
                else {
                    if (ctrlOrCmdPressed && !selectionIsFocus(model.selection)) {
                        addSelection(model.selection);
                    }
                    else {
                        clearOtherSelections();
                    }
                    model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);
                    model.setSelection(headerSelectionRange_1);
                }
            }
            else {
                if (ctrlOrCmdPressed) {
                    addSelection(model.selection);
                }
                model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);
            }
        }
    });
    function selectFromFocusToCell(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed, wasSelected) {
        var isCheckboxMode = (fromRow === 0 && toRow === Infinity && model.checkboxModeFor.cols) ||
            (fromCol === 0 && toCol === Infinity && model.checkboxModeFor.rows);
        if (!wasSelected || !isCheckboxMode) {
            setSelectionFromPoints(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed);
        }
        else {
            var range_1 = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);
            var prevSelections = findFullRowOrColSelections(range_1);
            if (prevSelections.length) {
                prevSelections.forEach(function (prevSelection) {
                    removeFullRowOrColFromSelection(prevSelection, range_1);
                });
            }
        }
    }
    function colSelectable(col) {
        var colDescriptor = grid.data.col.get(col);
        return colDescriptor && colDescriptor.selectable !== false;
    }
    function createHeaderSelectionRange(row, col) {
        var headerSelectionRange;
        if (row < 0 && col < 0) {
            headerSelectionRange = rangeUtil.createFromPoints(0, 0, Infinity, Infinity);
        }
        else if (row < 0) {
            if (colSelectable(col)) {
                headerSelectionRange = rangeUtil.createFromPoints(0, col, Infinity, col);
            }
        }
        else if (col < 0) {
            headerSelectionRange = rangeUtil.createFromPoints(row, 0, row, Infinity);
        }
        return headerSelectionRange;
    }
    function addOrSetSelection(selection) {
        if (!selectionIsFocus(model.selection)) {
            addSelection(selection);
        }
        else {
            model.setSelection(selection);
        }
    }
    function removeFullRowOrColFromSelection(selection, rowOrCol) {
        if (rowOrCol.width === Infinity) {
            var newSelections = [];
            if (selection.top < rowOrCol.top) {
                var newSelection = {
                    top: selection.top,
                    height: rowOrCol.top - selection.top,
                    left: selection.left,
                    width: selection.width
                };
                newSelections.push(newSelection);
            }
            var bottomRow = selection.top + selection.height - 1;
            if (bottomRow > rowOrCol.top + rowOrCol.height - 1) {
                newSelections.push({
                    top: rowOrCol.top + rowOrCol.height,
                    height: bottomRow - (rowOrCol.top + rowOrCol.height - 1),
                    left: selection.left,
                    width: selection.width
                });
            }
            removeSelection(selection);
            newSelections.forEach(addOrSetSelection);
            syncSelectionToHeaders();
        }
        if (rowOrCol.height === Infinity) {
        }
    }
    function findFullRowOrColSelections(range) {
        return model.getAllSelections().filter(function (selection) {
            return (selection.height === Infinity &&
                selection.top === 0 &&
                rangeUtil.intersect([selection.left, selection.width], [range.left, range.width]))
                ||
                    (selection.width === Infinity &&
                        selection.left === 0 &&
                        rangeUtil.intersect([selection.top, selection.height], [range.top, range.height]));
        });
    }
    function addSelection(range) {
        model.otherSelections.push(createAndAddSelectionDecorator(range.top, range.left, range.height, range.width));
    }
    function handleRowColSelectionChange(rowOrCol) {
        var decoratorsField = rowOrCol === 'row' ? '_rowSelectionClasses' : '_colSelectionClasses';
        var rowColModelField = rowOrCol === 'row' ? 'rowModel' : 'colModel';
        model[decoratorsField].forEach(function (selectionDecorator) {
            grid.cellClasses.remove(selectionDecorator);
        });
        model[decoratorsField] = [];
        if (grid[rowColModelField].allSelected()) {
            var top_1 = rowOrCol === 'row' ? Infinity : 0;
            var left = rowOrCol === 'col' ? Infinity : 0;
            var decorator = grid.cellClasses.create(top_1, left, 'selected', 1, 1, 'virtual');
            grid.cellClasses.add(decorator);
            model[decoratorsField].push(decorator);
        }
        else {
            grid[rowColModelField].getSelected().forEach(function (index) {
                var virtualIndex = grid[rowColModelField].toVirtual(index);
                var top = rowOrCol === 'row' ? virtualIndex : 0;
                var left = rowOrCol === 'col' ? virtualIndex : 0;
                var decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');
                grid.cellClasses.add(decorator);
                model[decoratorsField].push(decorator);
            });
        }
    }
    grid.eventLoop.bind('grid-row-selection-change', function () {
        handleRowColSelectionChange('row');
    });
    grid.eventLoop.bind('grid-col-selection-change', function () {
        handleRowColSelectionChange('col');
    });
    function createAndAddSelectionDecorator(t, l, h, w) {
        var selection = grid.decorators.create(t, l, h, w);
        var defaultRender = selection.render;
        selection.render = function () {
            var div = defaultRender();
            div.setAttribute('class', 'grid-selection');
            return div;
        };
        grid.decorators.add(selection);
        return selection;
    }
    function syncSelectionToHeaders() {
        grid.colModel.clearSelected();
        grid.rowModel.clearSelected();
        model.getAllSelections().forEach(function (s) {
            if (s) {
                maybeSelectHeaderFromSelection(s);
            }
        });
    }
    function maybeSelectHeaderFromSelection(range, deselect) {
        var indexes;
        if (range.top === 0 && range.height === Infinity) {
            indexes = grid.data.col.indexes({
                from: range.left,
                length: range.width
            });
            if (deselect) {
                grid.colModel.deselect(indexes);
            }
            else {
                grid.colModel.select(indexes);
            }
        }
        if (range.left === 0 && range.width === Infinity) {
            indexes = grid.data.row.indexes({
                from: range.top,
                length: range.height
            });
            if (deselect) {
                grid.rowModel.deselect(indexes);
            }
            else {
                grid.rowModel.select(indexes);
            }
        }
    }
    function selectionIsFocus(s) {
        return s.height === 1 && s.width === 1 && !model.otherSelections.length;
    }
    function setSelectionToFocus() {
        model.setSelection({
            top: model.focus.row,
            left: model.focus.col,
            height: 1,
            width: 1
        });
    }
    function clearOtherSelections() {
        grid.decorators.remove(model.otherSelections);
        model.otherSelections = [];
        syncSelectionToHeaders();
    }
    function isDecorator(s) {
        return !!s.space;
    }
    function removeSelection(selectionToRemove) {
        if (rangeUtil.equal(selectionToRemove, model.selection)) {
            if (model.otherSelections.length) {
                var lastSelection = model.otherSelections.pop();
                grid.decorators.remove(lastSelection);
                model.setSelection(lastSelection);
            }
            else {
                setSelectionToFocus();
            }
        }
        else if (isDecorator(selectionToRemove)) {
            var index = model.otherSelections.indexOf(selectionToRemove);
            if (index !== -1) {
                model.otherSelections.splice(index, 1);
                grid.decorators.remove(selectionToRemove);
            }
        }
        syncSelectionToHeaders();
    }
    function setSelectionFromPoints(fromRow, fromCol, toRow, toCol, dontClearOthers) {
        if (!dontClearOthers) {
            clearOtherSelections();
        }
        toRow = util.clamp(toRow, 0, Infinity);
        toCol = util.clamp(toCol, 0, Infinity);
        var newSelection = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);
        model.setSelection(newSelection);
    }
    mainSelection._onDragStart = function (e) {
        if (!isNavableMouseEvent(e)) {
            return;
        }
        if (e.enableAutoScroll) {
            e.enableAutoScroll();
        }
        var fromRow = model.focus.row;
        var fromCol = model.focus.col;
        var startCol = e.col;
        var startRow = e.row;
        var wasSelected;
        var toRow;
        var toCol;
        if (startRow < 0) {
            wasSelected = !grid.data.col.get(startCol).selected;
            fromRow = 0;
            toRow = Infinity;
        }
        if (startCol < 0) {
            wasSelected = !grid.data.row.get(startRow).selected;
            fromCol = 0;
            toCol = Infinity;
        }
        var unbindDrag = grid.eventLoop.bind('grid-cell-drag', function (gridCellDrag) {
            toRow = toRow !== Infinity ? gridCellDrag.row : toRow;
            toCol = toCol !== Infinity ? gridCellDrag.col : toCol;
            if (toCol !== Infinity && !colSelectable(toCol)) {
                return;
            }
            var fixedRows = grid.rowModel.numFixed(true);
            if (startRow < fixedRows && toRow > fixedRows && toRow !== Infinity) {
                startRow = toRow = grid.rowModel.numFixed();
                grid.cellScrollModel.scrollTo(0, grid.cellScrollModel.col);
            }
            var fixedCols = grid.colModel.numFixed(true);
            if (startCol < fixedCols && toCol > fixedCols && toCol !== Infinity) {
                startCol = toCol = grid.colModel.numFixed();
                grid.cellScrollModel.scrollTo(grid.cellScrollModel.row, 0);
            }
            if (isNaN(toRow) || isNaN(toCol)) {
                return;
            }
            selectFromFocusToCell(fromRow, fromCol, toRow, toCol, true, wasSelected);
        });
        var unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function () {
            unbindDrag();
            unbindDragEnd();
        });
    };
    grid.eventLoop.bind('grid-drag-start', mainSelection._onDragStart);
    setSelectionToFocus();
    function clearSelectionFromModelChange(e) {
        if (e.action === 'size') {
            return;
        }
        model.clearSelection();
    }
    grid.eventLoop.bind('grid-col-change', clearSelectionFromModelChange);
    grid.eventLoop.bind('grid-row-change', clearSelectionFromModelChange);
    return model;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var dirty_clean_1 = __webpack_require__(1);
var util = __webpack_require__(0);
function create(grid) {
    var pixelDirtyClean = dirty_clean_1.default(grid);
    var offsetDirtyClean = dirty_clean_1.default(grid);
    var scrollBarWidth = 10;
    var intentionAngle = 30;
    function makeDimension(gridDimension, gridCrossDimension) {
        function getViewScrollSize() {
            return gridDimension.viewPort.size - gridDimension.virtualPixelCell.fixedSize();
        }
        function getScrollRatioFromVirtualScrollCoords(scroll) {
            var maxScroll = pixelScrollDimension.maxScroll;
            var scrollRatio = scroll / maxScroll;
            return scrollRatio;
        }
        function getRealScrollBarPosition(scroll) {
            var scrollRatio = getScrollRatioFromVirtualScrollCoords(scroll);
            var maxScrollBarScroll = getMaxScrollBarCoord();
            var scrollBarCoord = scrollRatio * maxScrollBarScroll;
            return scrollBarCoord + gridDimension.virtualPixelCell.fixedSize();
        }
        function getMaxScroll() {
            if (pixelScrollDimension.maxIsAllTheWay) {
                return Math.max(0, pixelScrollDimension.scrollSize - gridDimension.virtualPixelCell.sizeOf(gridDimension.rowColModel.length(true) - 1));
            }
            var scrollLength = pixelScrollDimension.scrollSize;
            var viewScrollSize = getViewScrollSize();
            if (scrollLength <= viewScrollSize) {
                return 0;
            }
            var firstScrollableCell = gridDimension.rowColModel.numFixed();
            while (scrollLength > viewScrollSize - 10 && firstScrollableCell < gridDimension.rowColModel.length(true)) {
                scrollLength -= gridDimension.virtualPixelCell.sizeOf(firstScrollableCell);
                firstScrollableCell++;
            }
            return pixelScrollDimension.scrollSize - scrollLength;
        }
        function getMaxScrollBarCoord() {
            return getViewScrollSize() - (gridDimension.positionRange.getSize(pixelScrollDimension.scrollBar) || scrollBarWidth);
        }
        function getScrollPositionFromReal(scrollBarRealClickCoord) {
            var scrollBarTopClick = scrollBarRealClickCoord - gridDimension.virtualPixelCell.fixedSize();
            var scrollRatio = scrollBarTopClick / getMaxScrollBarCoord();
            var scrollCoord = scrollRatio * pixelScrollDimension.maxScroll;
            return scrollCoord;
        }
        function makeScrollBarDecorator() {
            var decorator = grid.decorators.create();
            decorator.fixed = true;
            var viewPortClampFn = gridDimension.viewPort.clampPx;
            decorator.postRender = function (scrollBarElem) {
                scrollBarElem.setAttribute('class', 'grid-scroll-bar');
                scrollBarElem.setAttribute('style', scrollBarElem.getAttribute('style') + " border-radius: 6px;\n                background: rgba(0, 0, 0, .5);\n                z-index: 10;");
                decorator._onDragStart = function (e) {
                    if (e.target !== scrollBarElem) {
                        return;
                    }
                    var scrollBarOffset = gridDimension.cellMouse.layerPx(e);
                    decorator._unbindDrag = grid.eventLoop.bind('grid-drag', function (gridDragEvent) {
                        grid.eventLoop.stopBubbling(gridDragEvent);
                        var gridCoord = viewPortClampFn(gridDimension.cellMouse.gridPx(gridDragEvent));
                        var scrollBarRealClickCoord = gridCoord - scrollBarOffset;
                        var scrollCoord = getScrollPositionFromReal(scrollBarRealClickCoord);
                        pixelScrollDimension.scrollTo(scrollCoord);
                    });
                    decorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function () {
                        if (decorator._unbindDrag) {
                            decorator._unbindDrag();
                        }
                        if (decorator._unbindDragEnd) {
                            decorator._unbindDragEnd();
                        }
                    });
                    e.stopPropagation();
                };
                grid.eventLoop.bind(scrollBarElem, 'grid-drag-start', decorator._onDragStart);
                grid.eventLoop.bind(scrollBarElem, 'mousedown', function (e) {
                    grid.eventLoop.stopBubbling(e);
                });
                return scrollBarElem;
            };
            decorator.units = 'px';
            decorator.space = 'real';
            gridCrossDimension.positionRange.setSize(decorator, scrollBarWidth);
            return decorator;
        }
        var pixelScrollDimension = {
            position: 0,
            offset: 0,
            maxScroll: 0,
            scrollSize: 0,
            maxIsAllTheWay: false,
            scrollTo: function (px, dontNotify) {
                pixelScrollDimension.position = util.clamp(px, 0, pixelScrollDimension.maxScroll);
                pixelScrollDimension.positionScrollBar();
                pixelScrollDimension.updatePixelOffset();
                if (!dontNotify) {
                    notifyListeners();
                }
            },
            updatePixelOffset: function () {
                var modPixels = 0;
                if (!grid.opts.snapToCell) {
                    var fixedSize = gridDimension.virtualPixelCell.fixedSize();
                    var rawCell = gridDimension.virtualPixelCell.toCellFromPx(pixelScrollDimension.position + fixedSize);
                    var cell = rawCell - gridDimension.rowColModel.numFixed();
                    var startCell = gridDimension.rowColModel.numFixed();
                    var endCell = cell + gridDimension.rowColModel.numFixed() - 1;
                    var position = gridDimension.virtualPixelCell.sizeOf(startCell, endCell);
                    modPixels = position - pixelScrollDimension.position;
                }
                if (pixelScrollDimension.offset !== modPixels) {
                    offsetDirtyClean.setDirty();
                }
                pixelScrollDimension.offset = modPixels;
            },
            scrollBar: makeScrollBarDecorator(),
            positionScrollBar: function () {
                gridDimension.positionRange.setPosition(pixelScrollDimension.scrollBar, getRealScrollBarPosition(pixelScrollDimension.position));
            },
            calcCellScrollPosition: function () {
                var position = pixelScrollDimension.position;
                var rawCell = gridDimension.virtualPixelCell.toCellFromPx(position + gridDimension.virtualPixelCell.fixedSize());
                return rawCell - gridDimension.rowColModel.numFixed();
            },
            sizeScrollBar: function () {
                gridCrossDimension.positionRange.setPosition(pixelScrollDimension.scrollBar, gridCrossDimension.viewPort.size - scrollBarWidth);
                var scrollableViewSize = getViewScrollSize();
                var scrollBarSize = Math.max(scrollableViewSize / gridDimension.virtualPixelCell.totalSize() * scrollableViewSize, 20);
                gridDimension.positionRange.setSize(pixelScrollDimension.scrollBar, scrollBarSize);
                if (scrollBarSize >= scrollableViewSize) {
                    gridDimension.positionRange.setSize(pixelScrollDimension.scrollBar, -1);
                }
            },
            cacheMaxScroll: function () {
                pixelScrollDimension.maxScroll = getMaxScroll();
            },
            cacheScrollSize: function () {
                pixelScrollDimension.scrollSize = gridDimension.virtualPixelCell.totalSize() - gridDimension.virtualPixelCell.fixedSize();
            },
            _getMaxScroll: getMaxScroll
        };
        return pixelScrollDimension;
    }
    var dimensions = {
        y: makeDimension(grid.rows, grid.cols),
        x: makeDimension(grid.cols, grid.rows),
    };
    var model = {
        get height() {
            return dimensions.y.scrollSize;
        },
        get width() {
            return dimensions.x.scrollSize;
        },
        get top() {
            return dimensions.y.position;
        },
        get left() {
            return dimensions.x.position;
        },
        get offsetTop() {
            return dimensions.y.offset;
        },
        get offsetLeft() {
            return dimensions.x.offset;
        },
        get vertScrollBar() {
            return dimensions.y.scrollBar;
        },
        get horzScrollBar() {
            return dimensions.x.scrollBar;
        },
        maxScroll: {
            get height() {
                return dimensions.y.scrollSize;
            },
            get width() {
                return dimensions.x.scrollSize;
            }
        },
        maxIsAllTheWayFor: {
            get height() {
                return dimensions.y.maxIsAllTheWay;
            },
            set height(h) {
                dimensions.y.maxIsAllTheWay = h;
            },
            get width() {
                return dimensions.x.maxIsAllTheWay;
            },
            set width(h) {
                dimensions.x.maxIsAllTheWay = h;
            },
        },
        isDirty: pixelDirtyClean.isDirty,
        isOffsetDirty: offsetDirtyClean.isDirty,
        setScrollSize: function (h, w) {
            model.y.scrollSize = h;
            model.x.scrollSize = w;
        },
        scrollTo: function (top, left, dontNotify) {
            model.y.scrollTo(top, true);
            model.x.scrollTo(left, true);
            if (!dontNotify) {
                notifyListeners();
            }
        },
        _getMaxScroll: function (heightOrWidth) {
            var dimension = heightOrWidth === 'height' ? model.y : model.x;
            return dimension._getMaxScroll();
        },
        y: dimensions.y,
        x: dimensions.x,
    };
    grid.eventLoop.bind('grid-virtual-pixel-cell-change', function () {
        model.y.cacheScrollSize();
        model.x.cacheScrollSize();
        cacheMaxScroll();
        sizeScrollBars();
        updatePixelOffsets();
    });
    grid.eventLoop.bind('grid-viewport-change', function () {
        cacheMaxScroll();
        sizeScrollBars();
        updatePixelOffsets();
    });
    function cacheMaxScroll() {
        model.y.cacheMaxScroll();
        model.x.cacheMaxScroll();
    }
    function checkAngle(side1, side2) {
        var angle = Math.abs(Math.atan(side1 / side2) * 57.29);
        return angle < intentionAngle;
    }
    grid.eventLoop.bind('mousewheel', function (e) {
        if (e.target !== grid.container && getScrollElementFromTarget(e.target, grid.container) !== grid.container) {
            return;
        }
        var deltaY = e.deltaY;
        var deltaX = e.deltaX;
        if (checkAngle(deltaY, deltaX)) {
            deltaY = 0;
        }
        else if (checkAngle(deltaX, deltaY)) {
            deltaX = 0;
        }
        model.scrollTo(model.top - deltaY, model.left - deltaX, false);
        e.preventDefault();
    });
    function notifyListeners() {
        grid.eventLoop.fire('grid-pixel-scroll');
        grid.cellScrollModel.scrollTo(model.y.calcCellScrollPosition(), model.x.calcCellScrollPosition(), undefined, true);
        pixelDirtyClean.setDirty();
    }
    function sizeScrollBars() {
        model.y.sizeScrollBar();
        model.x.sizeScrollBar();
        positionScrollBars();
    }
    function positionScrollBars() {
        model.y.positionScrollBar();
        model.x.positionScrollBar();
    }
    function updatePixelOffsets() {
        model.y.updatePixelOffset();
        model.x.updatePixelOffset();
    }
    grid.decorators.add(model.y.scrollBar);
    grid.decorators.add(model.x.scrollBar);
    var hasStyle = function (elem) { return !!elem.style; };
    function getScrollElementFromTarget(elem, stopParent) {
        stopParent = stopParent || document;
        if (!elem || !(hasStyle(elem))) {
            return stopParent;
        }
        var position = elem.style.position;
        var excludeStaticParent = position === 'absolute';
        var overflowRegex = /(auto|scroll)/;
        var scrollParent = elem;
        while (!!scrollParent && scrollParent !== stopParent) {
            if (!(excludeStaticParent && scrollParent.style.position === 'static')) {
                var computedStyle = getComputedStyle(scrollParent);
                if (overflowRegex.test('' + computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
                    break;
                }
            }
            scrollParent = scrollParent.parentElement;
        }
        return position === 'fixed' || !scrollParent || scrollParent === elem ? elem.ownerDocument || stopParent : scrollParent;
    }
    return model;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var abstract_row_col_model_1 = __webpack_require__(9);
var RowModel = (function (_super) {
    __extends(RowModel, _super);
    function RowModel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.height = function (idx) {
            return _this.sizeOf(idx);
        };
        _this.row = function (idx) {
            return _this.get(idx, true);
        };
        return _this;
    }
    return RowModel;
}(abstract_row_col_model_1.AbstractRowColModel));
exports.RowModel = RowModel;
function create(grid) {
    return new RowModel(grid, 'row', 'height', 30);
}
exports.create = create;
exports.default = create;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function create(grid) {
    var api = {
        _decorators: {}
    };
    function setColShowing(col) {
        grid.colModel.get(col).hidden = false;
    }
    function doWhileHidden(col, fn, inc) {
        var colDescriptor;
        while ((colDescriptor = grid.colModel.get(col)) !== undefined && colDescriptor.hidden) {
            if (fn) {
                fn(col);
            }
            col = col + inc;
        }
        return col;
    }
    function createDecorator(col, right) {
        var headerDecorator = grid.decorators.create(0, col, 1, 1, 'cell', 'virtual');
        headerDecorator.postRender = function (div) {
            if (right) {
                div.style.transform = 'translate(50%, -50%)';
                div.style.webkitTransform = 'translate(50%, -50%)';
                div.style.removeProperty('left');
            }
            else {
                div.style.transform = 'translate(-50%, -50%)';
                div.style.webkitTransform = 'translate(-50%, -50%)';
                div.style.removeProperty('right');
            }
            div.style.removeProperty('bottom');
            div.style.top = '50%';
            div.setAttribute('class', 'show-hidden-cols');
            div.setAttribute('dts', 'grid_column_unhide_btn');
            grid.eventLoop.bind(div, 'click', function () {
                var inc = right ? 1 : -1;
                doWhileHidden(col + inc, setColShowing, inc);
            });
        };
        return headerDecorator;
    }
    function maybeRemoveDecorator(col) {
        if (api._decorators[col]) {
            var decorator = api._decorators[col];
            if (decorator !== undefined) {
                grid.decorators.remove(decorator);
                api._decorators[col] = undefined;
            }
        }
    }
    grid.eventLoop.bind('grid-col-change', function (e) {
        if (e.action === 'hide' || e.action === 'add') {
            e.descriptors.forEach(function (descriptor) {
                var col = descriptor.index;
                if (!col && col !== 0) {
                    return;
                }
                if (descriptor.hidden) {
                    var decCol = col;
                    var showingCol = doWhileHidden(col, undefined, -1);
                    var rightSide = showingCol !== -1;
                    if (!rightSide) {
                        showingCol = doWhileHidden(col, undefined, 1);
                    }
                    decCol = showingCol;
                    maybeRemoveDecorator(col);
                    var decorator = createDecorator(decCol, rightSide);
                    grid.decorators.add(decorator);
                    api._decorators[col] = decorator;
                }
                else {
                    maybeRemoveDecorator(col);
                }
            });
        }
    });
    return api;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var converter_1 = __webpack_require__(7);
var dimensional_converter_1 = __webpack_require__(8);
var DataSpaceConverter = (function (_super) {
    __extends(DataSpaceConverter, _super);
    function DataSpaceConverter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.row = new DimensionalDataSpaceConverter(_this.grid.rows);
        _this.col = new DimensionalDataSpaceConverter(_this.grid.cols);
        return _this;
    }
    return DataSpaceConverter;
}(converter_1.AbstractSpaceConverter));
exports.DataSpaceConverter = DataSpaceConverter;
var DimensionalDataSpaceConverter = (function (_super) {
    __extends(DimensionalDataSpaceConverter, _super);
    function DimensionalDataSpaceConverter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DimensionalDataSpaceConverter.prototype.toData = function (i) {
        return i;
    };
    DimensionalDataSpaceConverter.prototype.toVirtual = function (dataCol) {
        return this.gridDimension.rowColModel.toVirtual(dataCol);
    };
    DimensionalDataSpaceConverter.prototype.count = function () {
        return this.gridDimension.rowColModel.length();
    };
    DimensionalDataSpaceConverter.prototype.toView = function (dataCol) {
        return this.gridDimension.converters.virtual.toView(this.toVirtual(dataCol));
    };
    return DimensionalDataSpaceConverter;
}(dimensional_converter_1.AbstractDimensionalSpaceConverter));


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var converter_1 = __webpack_require__(7);
var dimensional_converter_1 = __webpack_require__(8);
var ViewSpaceConverter = (function (_super) {
    __extends(ViewSpaceConverter, _super);
    function ViewSpaceConverter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.row = new DimensionalViewSpaceConverter(_this.grid.rows);
        _this.col = new DimensionalViewSpaceConverter(_this.grid.cols);
        return _this;
    }
    return ViewSpaceConverter;
}(converter_1.AbstractSpaceConverter));
exports.ViewSpaceConverter = ViewSpaceConverter;
var DimensionalViewSpaceConverter = (function (_super) {
    __extends(DimensionalViewSpaceConverter, _super);
    function DimensionalViewSpaceConverter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DimensionalViewSpaceConverter.prototype.toView = function (i) {
        return i;
    };
    DimensionalViewSpaceConverter.prototype.toData = function (viewCol) {
        return this.gridDimension.converters.virtual.toData(this.toVirtual(viewCol));
    };
    DimensionalViewSpaceConverter.prototype.toVirtual = function (viewCol) {
        return this.gridDimension.viewPort.toVirtual(viewCol);
    };
    DimensionalViewSpaceConverter.prototype.count = function () {
        return this.gridDimension.viewPort.count;
    };
    return DimensionalViewSpaceConverter;
}(dimensional_converter_1.AbstractDimensionalSpaceConverter));


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var converter_1 = __webpack_require__(7);
var dimensional_converter_1 = __webpack_require__(8);
var VirtualSpaceConverter = (function (_super) {
    __extends(VirtualSpaceConverter, _super);
    function VirtualSpaceConverter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.row = new DimensionalVirtualSpaceConverter(_this.grid.rows);
        _this.col = new DimensionalVirtualSpaceConverter(_this.grid.cols);
        return _this;
    }
    return VirtualSpaceConverter;
}(converter_1.AbstractSpaceConverter));
exports.VirtualSpaceConverter = VirtualSpaceConverter;
var DimensionalVirtualSpaceConverter = (function (_super) {
    __extends(DimensionalVirtualSpaceConverter, _super);
    function DimensionalVirtualSpaceConverter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DimensionalVirtualSpaceConverter.prototype.toVirtual = function (i) {
        return i;
    };
    DimensionalVirtualSpaceConverter.prototype.toData = function (virtualCol) {
        return this.gridDimension.rowColModel.toData(virtualCol);
    };
    DimensionalVirtualSpaceConverter.prototype.count = function () {
        return this.gridDimension.rowColModel.length(true);
    };
    DimensionalVirtualSpaceConverter.prototype.toView = function (virtualRow) {
        return this.gridDimension.viewPort.toReal(virtualRow);
    };
    return DimensionalVirtualSpaceConverter;
}(dimensional_converter_1.AbstractDimensionalSpaceConverter));


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var custom_event_1 = __webpack_require__(15);
var event_loop_1 = __webpack_require__(2);
var util = __webpack_require__(0);
function create(grid) {
    var container;
    var root;
    var cellContainerTL;
    var cellContainerTR;
    var cellContainerBL;
    var cellContainerBR;
    var decoratorContainerTL;
    var decoratorContainerTR;
    var decoratorContainerBL;
    var decoratorContainerBR;
    var borderWidth;
    var hoveredFixedRow;
    var hoveredRow;
    var GRID_CELL_CONTAINER_BASE_CLASS = 'grid-cells';
    var GRID_VIEW_ROOT_CLASS = 'js-grid-view-root';
    var CELL_CLASS = 'grid-cell';
    var cells;
    var rows = {
        fixed: [],
        nonFixed: []
    };
    var builtCols = {};
    var builtRows = {};
    var drawRequestedId;
    var viewLayer = {
        build: function (elem) {
            cleanup();
            container = elem;
            cellContainerTL = makeCellContainer();
            cellContainerTL.style.zIndex = '4';
            cellContainerTR = makeCellContainer();
            cellContainerTR.style.zIndex = '3';
            cellContainerBL = makeCellContainer();
            cellContainerBL.style.zIndex = '3';
            cellContainerBR = makeCellContainer();
            cellContainerBR.style.zIndex = '2';
            decoratorContainerTL = makeDecoratorContainer();
            decoratorContainerTL.style.zIndex = '4';
            decoratorContainerTR = makeDecoratorContainer();
            decoratorContainerTR.style.zIndex = '3';
            decoratorContainerTR.style.overflow = 'hidden';
            decoratorContainerBL = makeDecoratorContainer();
            decoratorContainerBL.style.zIndex = '3';
            decoratorContainerBL.style.overflow = 'hidden';
            decoratorContainerBR = makeDecoratorContainer();
            decoratorContainerBR.style.zIndex = '2';
            root = document.createElement('div');
            root.setAttribute('class', GRID_VIEW_ROOT_CLASS);
            root.appendChild(cellContainerTL);
            root.appendChild(cellContainerTR);
            root.appendChild(cellContainerBL);
            root.appendChild(cellContainerBR);
            root.appendChild(decoratorContainerTL);
            root.appendChild(decoratorContainerTR);
            root.appendChild(decoratorContainerBL);
            root.appendChild(decoratorContainerBR);
            container.appendChild(root);
        },
        draw: function () {
            if (drawRequestedId === undefined) {
                drawRequestedId = requestAnimationFrame(draw);
            }
        },
        eventIsOnCells: function (e) {
            var target = e.target;
            if (!target) {
                return false;
            }
            if (targetIsElement(target) && target.classList.contains('grid-cell') || target === grid.textarea) {
                return true;
            }
            if (!event_loop_1.isAnnotatedEvent(e)) {
                return false;
            }
            var renderedColElement = builtCols && builtCols[e.realCol];
            var renderedRowElement = builtRows && builtRows[e.realRow];
            if (renderedColElement && !grid.view.col.get(e.realCol).isBuiltActionable) {
                var elem = renderedColElement[e.realRow];
                return isTargetInElem(target, elem);
            }
            else if (renderedRowElement && !grid.view.row.get(e.realRow).isBuiltActionable) {
                var elem = renderedRowElement[e.realCol];
                return isTargetInElem(target, elem);
            }
            return false;
        },
        setTextContent: function (elem, text) {
            if (!elem) {
                return;
            }
            if (elem.firstChild && elem.firstChild.nodeType === 3) {
                elem.firstChild.nodeValue = text;
            }
            else {
                elem.textContent = text;
            }
        },
        getBorderWidth: getBorderWidth,
        _drawCells: drawCells,
        _buildCells: buildCells,
        _buildCols: buildCols,
        _buildRows: buildRows,
        _drawDecorators: drawDecorators,
        _drawCellClasses: drawCellClasses,
    };
    var targetIsElement = function (e) { return !!e.classList; };
    grid.cellClasses.add(grid.cellClasses.create(0, 0, CELL_CLASS, Infinity, Infinity, 'virtual'));
    var rowHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-row-header', Infinity, 0, 'virtual');
    var colHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-col-header', 0, Infinity, 'virtual');
    var fixedColClasses = grid.cellClasses.create(0, -1, 'grid-last-fixed-col', Infinity, 1, 'virtual');
    var fixedRowClasses = grid.cellClasses.create(-1, 0, 'grid-last-fixed-row', 1, Infinity, 'virtual');
    grid.cellClasses.add(rowHeaderClasses);
    grid.cellClasses.add(colHeaderClasses);
    grid.cellClasses.add(fixedRowClasses);
    grid.cellClasses.add(fixedColClasses);
    grid.eventLoop.bind('grid-col-change', function () {
        fixedColClasses.left = grid.colModel.numFixed() - 1;
        rowHeaderClasses.width = grid.colModel.numHeaders();
    });
    grid.eventLoop.bind('grid-row-change', function () {
        fixedRowClasses.top = grid.rowModel.numFixed() - 1;
        colHeaderClasses.height = grid.rowModel.numHeaders();
    });
    grid.eventLoop.bind('grid-cell-mouse-move', function (e) {
        var row = rows.fixed[e.realRow];
        if (!row || !viewLayer.eventIsOnCells(e)) {
            return;
        }
        row.classList.add('hover');
        if (hoveredFixedRow && hoveredFixedRow !== row) {
            hoveredFixedRow.classList.remove('hover');
        }
        hoveredFixedRow = row;
        row = rows.nonFixed[e.realRow];
        if (row) {
            row.classList.add('hover');
        }
        if (hoveredRow && hoveredRow !== row) {
            hoveredRow.classList.remove('hover');
        }
        hoveredRow = row;
    });
    function makeCellContainer() {
        var cellContainer = document.createElement('div');
        cellContainer.setAttribute('dts', 'grid-cells');
        cellContainer.setAttribute('class', GRID_CELL_CONTAINER_BASE_CLASS);
        cellContainer.style.zIndex = '';
        return cellContainer;
    }
    function makeDecoratorContainer() {
        var decoratorContainer = document.createElement('div');
        decoratorContainer.setAttribute('dts', 'grid-decorators');
        util.position(decoratorContainer, 0, 0, 0, 0);
        decoratorContainer.style.zIndex = '';
        decoratorContainer.style.pointerEvents = 'none';
        return decoratorContainer;
    }
    function offsetContainerForPixelScroll() {
        var modTopPixels = grid.pixelScrollModel.offsetTop;
        var modLeftPixels = grid.pixelScrollModel.offsetLeft;
        var fixedHeight = grid.virtualPixelCellModel.fixedHeight();
        var fixedWidth = grid.virtualPixelCellModel.fixedWidth();
        util.position(cellContainerTL, 0, 0, undefined, undefined, fixedHeight, fixedWidth);
        util.position(cellContainerBR, 0, 0, 0, 0);
        util.position3D(cellContainerBR, modTopPixels, modLeftPixels);
        util.position(cellContainerTR, 0, 0, undefined, 0, fixedHeight);
        util.position3D(cellContainerTR, 0, modLeftPixels);
        util.position(cellContainerBL, 0, 0, 0, undefined, undefined, fixedWidth);
        util.position3D(cellContainerBL, modTopPixels, 0);
        util.position(decoratorContainerTL, 0, 0, undefined, undefined, fixedHeight, fixedWidth);
        util.position(decoratorContainerBR, 0, 0, 0, 0);
        util.position3D(decoratorContainerBR, modTopPixels, modLeftPixels);
        util.position(decoratorContainerTR, 0, fixedWidth, undefined, 0, undefined, undefined);
        util.position3D(decoratorContainerTR, 0, 0);
        util.position(decoratorContainerBL, fixedHeight, 0, 0, undefined, undefined, undefined);
        util.position3D(decoratorContainerBL, 0, 0);
        grid.decorators.getAlive().forEach(function (decorator) {
            var decoratorTopOffset = 0;
            var decoratorLeftOffset = 0;
            if (decorator.scrollVert && !decorator.scrollHorz) {
                decoratorTopOffset = fixedHeight - modTopPixels;
            }
            else if (decorator.scrollHorz && !decorator.scrollVert) {
                decoratorLeftOffset = fixedWidth - modLeftPixels;
            }
            if (decorator.fixed) {
                if (decorator.scrollVert) {
                    decoratorTopOffset += modTopPixels;
                }
                if (decorator.scrollHorz) {
                    decoratorLeftOffset += modLeftPixels;
                }
            }
            if (decorator.boundingBox) {
                decorator.boundingBox.style.marginTop = -1 * decoratorTopOffset + 'px';
                decorator.boundingBox.style.marginLeft = -1 * decoratorLeftOffset + 'px';
            }
        });
    }
    function measureBorderWidth() {
        if (borderWidth) {
            return;
        }
        var jsGridCell = cells[0] && cells[0][0];
        if (jsGridCell) {
            var oldClass = jsGridCell.className;
            jsGridCell.className = CELL_CLASS;
            var computedStyle = getComputedStyle(jsGridCell);
            var borderWidthProp = computedStyle.getPropertyValue('border-left-width');
            borderWidth = parseInt(borderWidthProp, 10);
            jsGridCell.className = oldClass;
        }
        borderWidth = (!borderWidth || isNaN(borderWidth)) ? undefined : borderWidth;
        return borderWidth;
    }
    function draw() {
        drawRequestedId = undefined;
        if (!container || grid.destroyed) {
            return;
        }
        if (!grid.opts.snapToCell && grid.fps.slowCount > 10) {
            grid.opts.snapToCell = true;
        }
        var rebuilt = grid.viewPort.isDirty();
        if (rebuilt) {
            viewLayer._buildCells();
        }
        var builtColsDirty = grid.colModel.areBuildersDirty();
        if (rebuilt || builtColsDirty) {
            viewLayer._buildCols();
        }
        var builtRowsDirty = grid.rowModel.areBuildersDirty();
        if (rebuilt || builtRowsDirty) {
            viewLayer._buildRows();
        }
        var cellsPositionOrSizeChanged = grid.colModel.isDirty() || grid.rowModel.isDirty() || grid.cellScrollModel.isDirty();
        if (grid.cellClasses.isDirty() || rebuilt || cellsPositionOrSizeChanged) {
            viewLayer._drawCellClasses();
        }
        var drawingCells = rebuilt || cellsPositionOrSizeChanged || builtColsDirty || builtRowsDirty || grid.dataModel.isDirty();
        if (drawingCells) {
            viewLayer._drawCells();
        }
        var drawingDecorators = grid.decorators.isDirty() || rebuilt || cellsPositionOrSizeChanged;
        if (drawingDecorators) {
            viewLayer._drawDecorators(cellsPositionOrSizeChanged || rebuilt);
        }
        if (grid.pixelScrollModel.isOffsetDirty() || drawingDecorators) {
            offsetContainerForPixelScroll();
        }
        grid.eventLoop.fire('grid-draw');
    }
    function getBorderWidth() {
        return borderWidth || 1;
    }
    function drawCells() {
        measureBorderWidth();
        var bWidth = getBorderWidth();
        var headerRows = grid.rowModel.numHeaders();
        var headerCols = grid.colModel.numHeaders();
        var totalVisibleCellWidth = 0;
        var lastVirtualCol;
        var lastVirtualRow;
        var widths = [];
        var lefts = [];
        var virtualCols = [];
        function positionRow(row, height, top, virtualRow) {
            if (!row) {
                return;
            }
            if (height === 0 || lastVirtualRow === virtualRow) {
                row.style.display = 'none';
                return;
            }
            row.style.display = '';
            row.style.height = height + bWidth + 'px';
            row.style.top = top + 'px';
        }
        grid.viewPort.iterateCells(function drawCell(r, c) {
            var cell = cells[r][c];
            var width = widths[c] || (widths[c] = grid.viewPort.getColWidth(c));
            var virtualCol = virtualCols[c] || (virtualCols[c] = grid.viewPort.toVirtualCol(c));
            if (width === 0 || virtualCol === lastVirtualCol) {
                cell.style.display = 'none';
                return;
            }
            if (r === 0) {
                totalVisibleCellWidth += width;
            }
            lastVirtualCol = virtualCol;
            cell.style.display = '';
            cell.style.width = width + bWidth + 'px';
            var left = lefts[c] || (lefts[c] = grid.viewPort.getColLeft(c));
            cell.style.left = left + 'px';
            var virtualRow = grid.viewPort.toVirtualRow(r);
            var data = (r < headerRows || c < headerCols) ?
                grid.dataModel.getHeader(virtualRow, virtualCol) :
                grid.dataModel.get(grid.rowModel.toData(virtualRow), grid.colModel.toData(virtualCol));
            var builder = grid.rowModel.get(virtualRow).builder;
            var hasRowBuilder = true;
            if (!builder || (virtualCol < headerCols && !builder.includeHeaders)) {
                hasRowBuilder = false;
                builder = grid.colModel.get(virtualCol).builder;
                if (builder && virtualRow < headerRows && !builder.includeHeaders) {
                    builder = undefined;
                }
            }
            var cellChild;
            if (builder) {
                var builtElem = (hasRowBuilder) ?
                    builtRows[virtualRow][c] :
                    builtCols[virtualCol][r];
                cellChild = builder.update(builtElem, {
                    virtualCol: virtualCol,
                    virtualRow: virtualRow,
                    data: data
                });
            }
            if (!cellChild) {
                viewLayer.setTextContent(cell, data.formatted);
            }
            else {
                var notSameElem = cell.firstChild !== cellChild;
                if (cell.firstChild && notSameElem) {
                    cell.removeChild(cell.firstChild);
                }
                if (notSameElem) {
                    cell.appendChild(cellChild);
                }
            }
        }, function drawRow(r) {
            var height = grid.viewPort.getRowHeight(r);
            var virtualRow = grid.view.row.toVirtual(r);
            var top = grid.viewPort.getRowTop(r);
            positionRow(rows.fixed[r], height, top, virtualRow);
            positionRow(rows.nonFixed[r], height, top, virtualRow);
            lastVirtualRow = virtualRow;
            lastVirtualCol = undefined;
        });
        rows.nonFixed.forEach(function (row) {
            row.style.width = totalVisibleCellWidth + 'px';
        });
        rows.fixed.forEach(function (row) {
            row.style.width = grid.virtualPixelCellModel.fixedWidth() + 'px';
        });
        if (grid.cellScrollModel.row % 2) {
            cellContainerBR.className = GRID_CELL_CONTAINER_BASE_CLASS + ' odds';
            cellContainerBL.className = GRID_CELL_CONTAINER_BASE_CLASS + ' odds';
        }
        else {
            doToAllCellContainers(function (cellContainer) {
                cellContainer.className = GRID_CELL_CONTAINER_BASE_CLASS;
            });
        }
    }
    function clearCellContainer(cellContainer) {
        while (cellContainer.firstChild) {
            cellContainer.removeChild(cellContainer.firstChild);
        }
    }
    function doToAllCellContainers(fn) {
        fn(cellContainerTL);
        fn(cellContainerTR);
        fn(cellContainerBL);
        fn(cellContainerBR);
    }
    function getCellContainer(r, c) {
        var fixedRow = r < grid.rowModel.numFixed();
        var fixedCol = c < grid.colModel.numFixed();
        if (fixedRow && fixedCol) {
            return cellContainerTL;
        }
        else if (fixedRow) {
            return cellContainerTR;
        }
        else if (fixedCol) {
            return cellContainerBL;
        }
        return cellContainerBR;
    }
    function buildRow(r) {
        var row = document.createElement('div');
        row.setAttribute('class', 'grid-row');
        row.setAttribute('dts', 'grid-row');
        row.style.position = 'absolute';
        row.style.left = '0';
        if (r < grid.rowModel.numHeaders()) {
            row.classList.add('grid-is-header');
        }
        return row;
    }
    function buildCells() {
        doToAllCellContainers(clearCellContainer);
        cells = [];
        rows.fixed = [];
        rows.nonFixed = [];
        var row;
        grid.viewPort.iterateCells(function (r, c) {
            if (c === 0) {
                cells[r] = [];
            }
            if (c === grid.colModel.numFixed()) {
                row = rows.nonFixed[r] = buildRow(r);
            }
            else if (c === 0) {
                row = rows.fixed[r] = buildRow(r);
            }
            var cell = buildDivCell();
            cells[r][c] = cell;
            row.appendChild(cell);
            getCellContainer(r, c).appendChild(row);
        });
    }
    function buildDivCell() {
        var cell = document.createElement('div');
        cell.setAttribute('dts', 'grid-cell');
        var style = cell.style;
        style.position = 'absolute';
        style.boxSizing = 'border-box';
        style.top = '0px';
        style.bottom = '0px';
        return cell;
    }
    function destroyRenderedElems(oldElems) {
        if (!oldElems) {
            return;
        }
        oldElems.forEach(function (oldElem) {
            if (!oldElem) {
                return;
            }
            var destroyEvent = custom_event_1.default('grid-rendered-elem-destroy', true);
            oldElem.dispatchEvent(destroyEvent);
        });
    }
    function buildCols() {
        builtCols = buildDimension(grid.cols, grid.rows, builtCols, function (viewCol, viewRow, previousElement) { return ({
            viewRow: viewRow,
            viewCol: viewCol,
            previousElement: previousElement
        }); });
    }
    function buildRows() {
        builtRows = buildDimension(grid.rows, grid.cols, builtRows, function (viewRow, viewCol, previousElement) { return ({
            viewRow: viewRow,
            viewCol: viewCol,
            previousElement: previousElement
        }); });
    }
    function buildDimension(dimension, crossDimension, previouslyBuiltElems, getRenderContext) {
        var builtElems = {};
        for (var i = 0; i < dimension.rowColModel.length(true); i++) {
            var builder = dimension.rowColModel.get(i).builder;
            var oldElems = previouslyBuiltElems && previouslyBuiltElems[i];
            if (builder) {
                builtElems[i] = [];
                destroyRenderedElems(oldElems);
                for (var realI = 0; realI < crossDimension.viewPort.count; realI++) {
                    builtElems[i][realI] = builder.render(getRenderContext(dimension.converters.virtual.toView(i), realI, oldElems && oldElems[realI]));
                }
            }
        }
        return builtElems;
    }
    function setPosition(boundingBox, top, left, height, width) {
        var style = boundingBox.style;
        if (height <= 0 || width <= 0) {
            style.display = 'none';
            return false;
        }
        style.display = '';
        style.top = top + 'px';
        style.left = left + 'px';
        style.height = height + 'px';
        style.width = width + 'px';
        style.position = 'absolute';
    }
    function positionDecorator(bounding, t, l, h, w) {
        return setPosition(bounding, t, l, util.clamp(h, 0, grid.viewPort.height), util.clamp(w, 0, grid.viewPort.width));
    }
    function positionCellDecoratorFromViewCellRange(realCellRange, boundingBox) {
        var realPxRange = grid.viewPort.toPx(realCellRange);
        return positionDecorator(boundingBox, realPxRange.top, realPxRange.left, realPxRange.height && realPxRange.height + getBorderWidth(), realPxRange.width && realPxRange.width + getBorderWidth());
    }
    function createRangeForDescriptor(descriptor) {
        var range = {
            top: descriptor.top,
            left: descriptor.left,
            height: descriptor.height,
            width: descriptor.width
        };
        if (descriptor.space === 'data' && descriptor.units === 'cell') {
            range.top += grid.rowModel.numHeaders();
            range.left += grid.colModel.numHeaders();
        }
        return range;
    }
    function drawDecorators(cellsPositionOrSizeChanged) {
        var aliveDecorators = grid.decorators.getAlive();
        aliveDecorators.forEach(function (decorator) {
            var hasBeenRendered = !!decorator.boundingBox;
            var boundingBox = decorator.boundingBox || document.createElement('div');
            if (!hasBeenRendered) {
                boundingBox.style.pointerEvents = 'none';
                decorator.boundingBox = boundingBox;
                var decElement = decorator.render();
                if (decElement) {
                    boundingBox.appendChild(decElement);
                }
            }
            if (decorator.isDirty() || cellsPositionOrSizeChanged || !hasBeenRendered) {
                var vCol = decorator.left;
                var vRow = decorator.top;
                if (decorator.space === 'real') {
                    vCol = grid.view.col.toVirtual(vCol);
                    vRow = grid.view.row.toVirtual(vRow);
                    switch (decorator.units) {
                        case 'px':
                            positionDecorator(boundingBox, decorator.top, decorator.left, decorator.height, decorator.width);
                            break;
                        case 'cell':
                            positionCellDecoratorFromViewCellRange(decorator, boundingBox);
                            break;
                    }
                }
                else if (decorator.space === 'virtual' || decorator.space === 'data') {
                    if (decorator.space === 'data') {
                        vCol = grid.data.col.toVirtual(vCol);
                        vRow = grid.data.row.toVirtual(vRow);
                    }
                    switch (decorator.units) {
                        case 'px':
                            break;
                        case 'cell':
                        default:
                            var range = createRangeForDescriptor(decorator);
                            var realCellRange = grid.viewPort.intersect(range);
                            if (realCellRange) {
                                positionCellDecoratorFromViewCellRange(realCellRange, boundingBox);
                            }
                            else {
                                positionDecorator(boundingBox, -1, -1, -1, -1);
                            }
                            break;
                    }
                }
                var parent_1 = boundingBox.parentElement;
                if (parent_1) {
                    parent_1.removeChild(boundingBox);
                }
                var fixedRow = vRow < grid.rowModel.numFixed();
                var fixedCol = vCol < grid.colModel.numFixed();
                if (fixedRow && fixedCol) {
                    decorator.scrollHorz = false;
                    decorator.scrollVert = false;
                    decoratorContainerTL.appendChild(boundingBox);
                }
                else if (fixedRow) {
                    decorator.scrollHorz = true;
                    decorator.scrollVert = false;
                    decoratorContainerTR.appendChild(boundingBox);
                }
                else if (fixedCol) {
                    decorator.scrollHorz = false;
                    decorator.scrollVert = true;
                    decoratorContainerBL.appendChild(boundingBox);
                }
                else {
                    decorator.scrollHorz = true;
                    decorator.scrollVert = true;
                    decoratorContainerBR.appendChild(boundingBox);
                }
            }
        });
        removeDecorators(grid.decorators.popAllDead());
    }
    function removeDecorators(decorators) {
        decorators.forEach(function (decorator) {
            if (!decorator) {
                return;
            }
            var boundingBox = decorator.boundingBox;
            if (boundingBox) {
                var renderedElement = boundingBox.firstChild;
                if (renderedElement) {
                    var destroyEvent = custom_event_1.default('decorator-destroy', true);
                    renderedElement.dispatchEvent(destroyEvent);
                }
                var parent_2 = boundingBox.parentElement;
                if (parent_2) {
                    parent_2.removeChild(boundingBox);
                }
                decorator.boundingBox = undefined;
            }
        });
    }
    function drawCellClasses() {
        grid.viewPort.iterateCells(function (r, c) {
            var classes = grid.cellClasses.getCachedClasses(grid.view.row.toVirtual(r), grid.view.col.toVirtual(c));
            cells[r][c].className = classes.join(' ');
        });
    }
    function destroyPreviouslyBuilt(built) {
        if (!built) {
            return;
        }
        Object.keys(built).forEach(function (key) {
            destroyRenderedElems(built[key]);
        });
    }
    function cleanup() {
        removeDecorators(grid.decorators.getAlive().concat(grid.decorators.popAllDead()));
        destroyPreviouslyBuilt(builtCols);
        destroyPreviouslyBuilt(builtRows);
        if (!container) {
            return;
        }
        var gridViewRoots = container.querySelectorAll('.' + GRID_VIEW_ROOT_CLASS);
        for (var i = 0; i < gridViewRoots.length; ++i) {
            container.removeChild(gridViewRoots[i]);
        }
    }
    function isTargetInElem(target, elem) {
        if (!target || !targetIsElement(target)) {
            return false;
        }
        var t = target;
        while (t && !t.classList.contains('grid-container')) {
            if (t === elem) {
                return true;
            }
            t = t.parentElement;
        }
        return false;
    }
    grid.eventLoop.bind('grid-destroy', function () {
        cleanup();
        if (drawRequestedId) {
            cancelAnimationFrame(drawRequestedId);
        }
        viewLayer.draw = function () { };
    });
    return viewLayer;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var debounce_1 = __webpack_require__(6);
var dirty_clean_1 = __webpack_require__(1);
var dirty_props_1 = __webpack_require__(4);
var rangeUtil = __webpack_require__(11);
var util = __webpack_require__(0);
function create(grid) {
    var dirtyClean = dirty_clean_1.default(grid);
    var container;
    function getFirstClientRect() {
        return container && container.getClientRects && container.getClientRects()[0];
    }
    function makeDimension(gridDimension) {
        function getVirtualRowColUnsafe(coord) {
            var numFixed = viewDimension._numFixed;
            if (coord < numFixed) {
                return coord;
            }
            return coord + gridDimension.cellScroll.position;
        }
        function getLengthBetweenViewCoords(startCoord, endCoord, inclusive) {
            var toVirtual = viewDimension.toVirtual;
            var lengthFn = gridDimension.virtualPixelCell.sizeOf;
            var clampFn = viewDimension.clampCell;
            var pos = 0;
            var numFixed = viewDimension._numFixed;
            var isInNonfixedArea = endCoord >= numFixed;
            var isInFixedArea = startCoord < numFixed;
            var exclusiveOffset = (inclusive ? 0 : 1);
            if (isInFixedArea) {
                var fixedEndCoord = (isInNonfixedArea ? numFixed - 1 : endCoord - exclusiveOffset);
                pos += lengthFn(startCoord, fixedEndCoord);
            }
            if (isInNonfixedArea) {
                var startOfNonFixed = isInFixedArea ? toVirtual(numFixed) : toVirtual(startCoord);
                pos += lengthFn(startOfNonFixed, toVirtual(clampFn(endCoord)) - exclusiveOffset);
            }
            return pos;
        }
        function getRowOrColFromPosition(pos, returnVirtual) {
            var viewMax = viewDimension.count;
            var toVirtual = viewDimension.toVirtual;
            var lengthFn = gridDimension.virtualPixelCell.sizeOf;
            var fixedSize = gridDimension.virtualPixelCell.fixedSize();
            var summedLength = grid.viewLayer.getBorderWidth() + (pos <= fixedSize ? 0 : gridDimension.pixelScroll.offset);
            for (var i = 0; i < viewMax; i++) {
                var virtual = toVirtual(i);
                var length_1 = lengthFn(virtual);
                var newSum = summedLength + length_1;
                if (newSum >= pos) {
                    return returnVirtual ? virtual : i;
                }
                summedLength = newSum;
            }
            return NaN;
        }
        function calculateMaxLengths(totalLength) {
            var lengthMethod = gridDimension.virtualPixelCell.sizeOf;
            var numFixed = gridDimension.rowColModel.numFixed();
            var windowLength = 0;
            var maxSize = 0;
            var fixedLength = 0;
            var windowStartIndex = numFixed;
            for (var fixed = 0; fixed < numFixed; fixed++) {
                fixedLength += lengthMethod(fixed);
            }
            var maxLength = 0;
            for (var index = numFixed; index < gridDimension.rowColModel.length(true); index++) {
                var lengthOfIindex = lengthMethod(index);
                if (lengthOfIindex > maxLength) {
                    maxLength = lengthOfIindex;
                }
            }
            totalLength += maxLength;
            for (var index = numFixed; index < gridDimension.rowColModel.length(true); index++) {
                var lengthOfIindex = lengthMethod(index);
                windowLength += lengthOfIindex;
                while (windowLength + fixedLength > totalLength && windowStartIndex < index) {
                    windowLength -= lengthMethod(windowStartIndex);
                    windowStartIndex++;
                }
                var windowSize = index - windowStartIndex + 1;
                if (windowSize > maxSize) {
                    maxSize = windowSize;
                }
            }
            return Math.min(maxSize + numFixed + 1, gridDimension.rowColModel.length(true));
        }
        var viewDimension = dirty_props_1.default({
            count: 0,
            size: 0,
            clientPx: {
                get start() {
                    var clientRect = getFirstClientRect();
                    return clientRect && gridDimension.positionRange.getPosition(clientRect) || 0;
                },
                toGrid: function (clientPx) {
                    return clientPx - viewDimension.clientPx.start;
                }
            },
            _numFixed: 0,
            isInView: function (virtualCoord) {
                var realRow = viewDimension.toReal(virtualCoord);
                return !isNaN(realRow) &&
                    getLengthBetweenViewCoords(0, realRow, true) < viewDimension.totalSize();
            },
            toVirtual: function (viewCoord) {
                var virtualRowCol = getVirtualRowColUnsafe(viewCoord);
                return gridDimension.virtualPixelCell.clampCell(virtualRowCol);
            },
            toReal: function (virtualCoord) {
                var numFixed = viewDimension._numFixed;
                if (virtualCoord < numFixed) {
                    return virtualCoord;
                }
                var maxViewPortIndex = viewDimension.count - 1;
                return util.clamp(virtualCoord - gridDimension.cellScroll.position, numFixed, maxViewPortIndex, true);
            },
            clampCell: function (coord) {
                return util.clamp(coord, 0, viewDimension.count - 1);
            },
            clampPx: function (px) {
                return util.clamp(px, 0, viewDimension.totalSize());
            },
            toPx: function (coord) {
                return getLengthBetweenViewCoords(0, coord);
            },
            toVirtualFromPx: function (px) {
                return getRowOrColFromPosition(px, true);
            },
            toViewFromPx: function (px) {
                return getRowOrColFromPosition(px);
            },
            sizeOf: function (viewCoord) {
                return gridDimension.virtualPixelCell.sizeOf(viewDimension.toVirtual(viewDimension.clampCell(viewCoord)));
            },
            totalSize: function () {
                return viewDimension.size;
            },
            intersect: function (intersection, range) {
                var numFixed = viewDimension._numFixed;
                var fixedRange = [0, numFixed];
                var virtualRange = [gridDimension.positionRange.getPosition(range), gridDimension.positionRange.getSize(range)];
                var fixedIntersection = rangeUtil.intersect(fixedRange, virtualRange);
                var scrollRange = [numFixed, viewDimension.count - numFixed];
                virtualRange[0] -= gridDimension.cellScroll.position;
                var scrollIntersection = rangeUtil.intersect(scrollRange, virtualRange);
                var resultRange = rangeUtil.union(fixedIntersection, scrollIntersection);
                if (!resultRange) {
                    return null;
                }
                gridDimension.positionRange.setPosition(intersection, resultRange[0]);
                gridDimension.positionRange.setSize(intersection, resultRange[1]);
                return intersection;
            },
            updateSize: function (newSize) {
                var oldSize = viewDimension.size;
                viewDimension.size = newSize;
                viewDimension.count = calculateMaxLengths(newSize);
                return oldSize !== newSize;
            },
            _getLengthBetweenCoords: getLengthBetweenViewCoords
        }, ['count', 'size'], [dirtyClean]);
        return viewDimension;
    }
    var dimensions = {
        rowInfo: makeDimension(grid.rows),
        colInfo: makeDimension(grid.cols)
    };
    var viewPort = {
        _onResize: debounce_1.default(function () {
            viewPort._resize();
        }, 200),
        shortDebouncedResize: debounce_1.default(function () {
            viewPort._resize();
        }, 1),
        isDirty: dirtyClean.isDirty,
        sizeToContainer: function (elem) {
            container = elem;
            var isHeightChange = viewPort.rowInfo.updateSize(elem.offsetHeight);
            var isWidthChange = viewPort.colInfo.updateSize(elem.offsetWidth);
            var event = {
                type: 'grid-viewport-change',
                isWidthChange: isWidthChange,
                isHeightChange: isHeightChange,
                isSizeChange: isWidthChange || isHeightChange,
            };
            grid.eventLoop.fire(event);
        },
        _resize: function () {
            if (container) {
                viewPort.sizeToContainer(container);
            }
        },
        toPx: function (realCellRange) {
            return {
                top: viewPort.getRowTop(realCellRange.top),
                left: viewPort.getColLeft(realCellRange.left),
                height: viewPort.rowInfo._getLengthBetweenCoords(realCellRange.top, realCellRange.top + realCellRange.height - 1, true),
                width: viewPort.colInfo._getLengthBetweenCoords(realCellRange.left, realCellRange.left + realCellRange.width - 1, true)
            };
        },
        intersect: function (range) {
            var intersection = viewPort.rowInfo.intersect({}, range);
            if (!intersection) {
                return null;
            }
            return viewPort.colInfo.intersect(intersection, range);
        },
        iterateCells: function (cellFn, rowFn, maxRow, maxCol) {
            if (maxRow === void 0) { maxRow = Infinity; }
            if (maxCol === void 0) { maxCol = Infinity; }
            for (var r = 0; r < Math.min(viewPort.rows, maxRow); r++) {
                if (rowFn) {
                    rowFn(r);
                }
                if (cellFn) {
                    for (var c = 0; c < Math.min(viewPort.cols, maxCol); c++) {
                        cellFn(r, c);
                    }
                }
            }
        },
        get rows() {
            return dimensions.rowInfo.count;
        },
        set rows(r) {
            dimensions.rowInfo.count = r;
        },
        get cols() {
            return dimensions.colInfo.count;
        },
        set cols(c) {
            dimensions.colInfo.count = c;
        },
        get height() {
            return dimensions.rowInfo.size;
        },
        set height(s) {
            dimensions.rowInfo.size = s;
        },
        get width() {
            return dimensions.colInfo.size;
        },
        set width(s) {
            dimensions.colInfo.size = s;
        },
        get top() {
            return dimensions.rowInfo.clientPx.start;
        },
        get left() {
            return dimensions.colInfo.clientPx.start;
        },
        toGridY: dimensions.rowInfo.clientPx.toGrid,
        toGridX: dimensions.colInfo.clientPx.toGrid,
        toVirtualRow: dimensions.rowInfo.toVirtual,
        toVirtualCol: dimensions.colInfo.toVirtual,
        rowIsInView: dimensions.rowInfo.isInView,
        colIsInView: dimensions.colInfo.isInView,
        toRealRow: dimensions.rowInfo.toReal,
        toRealCol: dimensions.colInfo.toReal,
        clampRow: dimensions.rowInfo.clampCell,
        clampCol: dimensions.colInfo.clampCell,
        clampY: dimensions.rowInfo.clampPx,
        clampX: dimensions.colInfo.clampPx,
        getRowTop: dimensions.rowInfo.toPx,
        getColLeft: dimensions.colInfo.toPx,
        getVirtualRowByTop: dimensions.rowInfo.toVirtualFromPx,
        getVirtualColByLeft: dimensions.colInfo.toVirtualFromPx,
        getRowByTop: dimensions.rowInfo.toViewFromPx,
        getColByLeft: dimensions.colInfo.toViewFromPx,
        getRowHeight: dimensions.rowInfo.sizeOf,
        getColWidth: dimensions.colInfo.sizeOf,
        rowInfo: dimensions.rowInfo,
        colInfo: dimensions.colInfo,
    };
    grid.eventLoop.bind('grid-destroy', function () {
        viewPort._onResize.cancel();
        viewPort.shortDebouncedResize.cancel();
    });
    grid.eventLoop.bind(window, 'resize', function () {
        viewPort._onResize();
    });
    grid.eventLoop.bind('grid-row-change', function () {
        viewPort.rowInfo._numFixed = grid.rowModel.numFixed();
        viewPort.shortDebouncedResize();
    });
    grid.eventLoop.bind('grid-col-change', function () {
        viewPort.colInfo._numFixed = grid.colModel.numFixed();
        viewPort.shortDebouncedResize();
    });
    return viewPort;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(0);
function makeDimension(gridDimension) {
    var dimension = {
        toCellFromPx: function (px) {
            if (px < 0) {
                return NaN;
            }
            var sumLength = 0;
            for (var r = 0; r < gridDimension.rowColModel.length(true); r++) {
                sumLength += gridDimension.rowColModel.sizeOf(r);
                if (px < sumLength) {
                    return r;
                }
            }
            return NaN;
        },
        clampCell: function (cell) {
            var maxRowCol = gridDimension.rowColModel.length(true) - 1;
            return util.clamp(cell, 0, maxRowCol);
        },
        sizeOf: function (start, end) {
            var length = 0;
            if (end != undefined && end < start) {
                return 0;
            }
            end = util.isNumber(end) ? end : start;
            end = dimension.clampCell(end);
            start = dimension.clampCell(start);
            for (var i = start; i <= end; i++) {
                length += gridDimension.rowColModel.sizeOf(i);
            }
            return length;
        },
        totalSize: function () {
            return dimension.sizeOf(0, gridDimension.rowColModel.length(true) - 1);
        },
        fixedSize: function () {
            return dimension.sizeOf(0, gridDimension.rowColModel.numFixed() - 1);
        },
    };
    return dimension;
}
function create(grid) {
    var dimensions = {
        rows: makeDimension(grid.rows),
        cols: makeDimension(grid.cols),
    };
    var virtualPixelCellModel = {
        getRow: dimensions.rows.toCellFromPx,
        getCol: dimensions.cols.toCellFromPx,
        clampRow: dimensions.rows.clampCell,
        clampCol: dimensions.cols.clampCell,
        height: dimensions.rows.sizeOf,
        width: dimensions.cols.sizeOf,
        totalHeight: dimensions.rows.totalSize,
        totalWidth: dimensions.cols.totalSize,
        fixedHeight: dimensions.rows.fixedSize,
        fixedWidth: dimensions.cols.fixedSize,
        rows: dimensions.rows,
        cols: dimensions.cols,
    };
    function sizeChangeListener() {
        grid.eventLoop.fire('grid-virtual-pixel-cell-change');
    }
    grid.eventLoop.bind('grid-col-change', sizeChangeListener);
    grid.eventLoop.bind('grid-row-change', sizeChangeListener);
    return virtualPixelCellModel;
}
exports.create = create;
exports.default = create;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(38);


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(39).polyfill();
var cell_classes_1 = __webpack_require__(12);
var cell_keyboard_model_1 = __webpack_require__(13);
var cell_mouse_model_1 = __webpack_require__(14);
var cell_scroll_model_1 = __webpack_require__(16);
var col_model_1 = __webpack_require__(17);
var col_reorder_1 = __webpack_require__(18);
var col_resize_1 = __webpack_require__(21);
var copy_paste_1 = __webpack_require__(22);
var data_model_1 = __webpack_require__(10);
var decorators_1 = __webpack_require__(23);
var dirty_clean_1 = __webpack_require__(1);
var edit_model_1 = __webpack_require__(24);
var event_loop_1 = __webpack_require__(2);
var fps_1 = __webpack_require__(26);
var navigation_model_1 = __webpack_require__(27);
var pixel_scroll_model_1 = __webpack_require__(28);
var position_range_1 = __webpack_require__(5);
var row_model_1 = __webpack_require__(29);
var show_hidden_cols_1 = __webpack_require__(30);
var data_space_converter_1 = __webpack_require__(31);
var view_space_converter_1 = __webpack_require__(32);
var virtual_space_converter_1 = __webpack_require__(33);
var util = __webpack_require__(0);
var view_layer_1 = __webpack_require__(34);
var view_port_1 = __webpack_require__(35);
var virtual_pixel_cell_model_1 = __webpack_require__(36);
var escapeStack = __webpack_require__(53);
var elementClass = __webpack_require__(20);
function create(opts) {
    if (opts === void 0) { opts = {}; }
    var lazyGetterMap = {};
    var lazyGetter = function (idx, getFn) {
        if (lazyGetterMap[idx] === undefined) {
            lazyGetterMap[idx] = getFn();
        }
        return lazyGetterMap[idx];
    };
    var userSuppliedEscapeStack;
    var drawRequested = false;
    var timeouts = [];
    var intervals = [];
    var gridCore = {
        opts: opts,
        focused: false,
        destroyed: false,
        textarea: createFocusTextArea(),
        get escapeStack() {
            return userSuppliedEscapeStack || escapeStack(true);
        },
        set escapeStack(v) {
            userSuppliedEscapeStack = v;
        },
        requestDraw: function () {
            if (!grid.viewLayer || !grid.viewLayer.draw) {
                return;
            }
            if (!grid.eventLoop.isRunning) {
                grid.viewLayer.draw();
            }
            else {
                drawRequested = true;
            }
        },
        get data() {
            return lazyGetter('data', function () { return new data_space_converter_1.DataSpaceConverter(grid); });
        },
        get view() {
            return lazyGetter('view', function () { return new view_space_converter_1.ViewSpaceConverter(grid); });
        },
        get virtual() {
            return lazyGetter('virtual', function () { return new virtual_space_converter_1.VirtualSpaceConverter(grid); });
        },
        timeout: function () {
            if (grid.destroyed) {
                return;
            }
            var id = window.setTimeout.apply(window, arguments);
            timeouts.push(id);
            return id;
        },
        interval: function () {
            if (grid.destroyed) {
                return;
            }
            var id = window.setInterval.apply(window, arguments);
            intervals.push(id);
            return id;
        },
        build: function (container) {
            grid.container = container;
            setupTextareaForContainer(grid.textarea, container);
            grid.viewPort.sizeToContainer(container);
            grid.viewLayer.build(container);
            grid.eventLoop.setContainer(container);
            container.style.overflow = 'hidden';
            container.addEventListener('scroll', function () {
                container.scrollTop = 0;
                container.scrollLeft = 0;
            });
        },
        makeDirtyClean: function () {
            return dirty_clean_1.default(grid);
        },
        eventIsOnCells: function (e) {
            return grid.viewLayer.eventIsOnCells(e);
        },
        destroy: function () {
            grid.eventLoop.fire('grid-destroy');
        },
        rows: {
            get rowColModel() {
                return grid.rowModel;
            },
            get viewPort() {
                return grid.viewPort.rowInfo;
            },
            get cellScroll() {
                return grid.cellScrollModel.rowInfo;
            },
            get pixelScroll() {
                return grid.pixelScrollModel.y;
            },
            get positionRange() {
                return position_range_1.rowPositionRangeDimension;
            },
            get cellMouse() {
                return grid.cellMouseModel.rowInfo;
            },
            get virtualPixelCell() {
                return grid.virtualPixelCellModel.rows;
            },
            converters: {
                get virtual() {
                    return gridCore.virtual.row;
                },
                get view() {
                    return gridCore.view.row;
                },
                get data() {
                    return gridCore.data.row;
                },
            }
        },
        cols: {
            get rowColModel() {
                return grid.colModel;
            },
            get viewPort() {
                return grid.viewPort.colInfo;
            },
            get cellScroll() {
                return grid.cellScrollModel.colInfo;
            },
            get pixelScroll() {
                return grid.pixelScrollModel.x;
            },
            get positionRange() {
                return position_range_1.colPositionRangeDimension;
            },
            get cellMouse() {
                return grid.cellMouseModel.colInfo;
            },
            get virtualPixelCell() {
                return grid.virtualPixelCellModel.cols;
            },
            converters: {
                get virtual() {
                    return gridCore.virtual.col;
                },
                get view() {
                    return gridCore.view.col;
                },
                get data() {
                    return gridCore.data.col;
                },
            }
        }
    };
    var grid = gridCore;
    grid.eventLoop = event_loop_1.default();
    grid.decorators = decorators_1.default(grid);
    grid.cellClasses = cell_classes_1.default(grid);
    grid.rowModel = row_model_1.default(grid);
    grid.colModel = col_model_1.default(grid);
    grid.dataModel = data_model_1.default(grid, opts.loadRows);
    grid.virtualPixelCellModel = virtual_pixel_cell_model_1.default(grid);
    grid.cellScrollModel = cell_scroll_model_1.default(grid);
    grid.cellMouseModel = cell_mouse_model_1.default(grid);
    grid.cellKeyboardModel = cell_keyboard_model_1.default(grid);
    grid.fps = fps_1.default(grid);
    grid.viewPort = view_port_1.default(grid);
    grid.viewLayer = view_layer_1.default(grid);
    if (!(opts.col && opts.col.disableReorder)) {
        grid.colReorder = col_reorder_1.default(grid);
    }
    if (opts.allowEdit) {
        grid.editModel = edit_model_1.default(grid);
    }
    grid.navigationModel = navigation_model_1.default(grid);
    grid.pixelScrollModel = pixel_scroll_model_1.default(grid);
    grid.showHiddenCols = show_hidden_cols_1.default(grid);
    if (!(opts.col && opts.col.disableResize)) {
        grid.colResize = col_resize_1.default(grid);
    }
    grid.copyPaste = copy_paste_1.default(grid);
    grid.eventLoop.addExitListener(function () {
        if (drawRequested) {
            grid.viewLayer.draw();
        }
    });
    function setupTextareaForContainer(textarea, container) {
        textarea.addEventListener('focus', function () {
            if (container) {
                elementClass(container).add('focus');
            }
            textarea.select();
            grid.focused = true;
            grid.eventLoop.fire('grid-focus');
        });
        textarea.addEventListener('blur', function () {
            if (container) {
                elementClass(container).remove('focus');
            }
            grid.focused = false;
            grid.eventLoop.fire('grid-blur');
        });
        var widthResetTimeout;
        grid.eventLoop.addInterceptor(function (e) {
            if (e.type !== 'mousedown' || e.button !== 2) {
                return;
            }
            textarea.style.width = '100%';
            textarea.style.height = '100%';
            textarea.style.zIndex = '1';
            if (widthResetTimeout) {
                clearTimeout(widthResetTimeout);
            }
            widthResetTimeout = window.setTimeout(function () {
                textarea.style.zIndex = '0';
                textarea.style.width = '0px';
                textarea.style.height = '1px';
            }, 1);
        });
        container.appendChild(textarea);
        if (!container.getAttribute('tabIndex')) {
            container.tabIndex = -1;
        }
        container.addEventListener('focus', function () {
            if (textarea) {
                textarea.focus();
            }
        });
    }
    function createFocusTextArea() {
        var textarea = document.createElement('textarea');
        textarea.setAttribute('dts', 'grid-textarea');
        util.position(textarea, 0, 0);
        textarea.style.width = '0px';
        textarea.style.height = '1px';
        textarea.style.maxWidth = '100%';
        textarea.style.maxHeight = '100%';
        textarea.style.zIndex = '0';
        textarea.style.overflow = 'hidden';
        textarea.style.background = 'transparent';
        textarea.style.color = 'transparent';
        textarea.style.border = 'none';
        textarea.style.boxShadow = 'none';
        textarea.style.resize = 'none';
        textarea.style.cursor = 'default';
        textarea.classList.add('grid-textarea');
        textarea.setAttribute('ondragstart', 'return false;');
        return textarea;
    }
    grid.eventLoop.bind('grid-destroy', function () {
        intervals.forEach(function (id) {
            clearInterval(id);
        });
        timeouts.forEach(function (id) {
            clearTimeout(id);
        });
    });
    return grid;
}
exports.create = create;
exports.default = create;
__export(__webpack_require__(9));
__export(__webpack_require__(12));
__export(__webpack_require__(13));
__export(__webpack_require__(14));
__export(__webpack_require__(16));
__export(__webpack_require__(17));
__export(__webpack_require__(18));
__export(__webpack_require__(21));
__export(__webpack_require__(22));
__export(__webpack_require__(10));
__export(__webpack_require__(10));
__export(__webpack_require__(23));
__export(__webpack_require__(1));
__export(__webpack_require__(24));
__export(__webpack_require__(2));
__export(__webpack_require__(26));
__export(__webpack_require__(27));
__export(__webpack_require__(28));
__export(__webpack_require__(5));
__export(__webpack_require__(29));
__export(__webpack_require__(30));
__export(__webpack_require__(7));
__export(__webpack_require__(31));
__export(__webpack_require__(8));
__export(__webpack_require__(32));
__export(__webpack_require__(33));
__export(__webpack_require__(0));
__export(__webpack_require__(34));
__export(__webpack_require__(35));
__export(__webpack_require__(36));


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */



function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}

module.exports = {
  assign: assign,
  polyfill: polyfill
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function create() {
    var listeners = [];
    return {
        addListener: function (fn) {
            listeners.push(fn);
            return function () {
                listeners.splice(listeners.indexOf(fn), 1);
            };
        },
        notify: function (e) {
            listeners.forEach(function (listener) {
                listener(e);
            });
        }
    };
}
exports.create = create;
exports.default = create;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EVENT_NAMES = ['mousewheel', 'wheel', 'DOMMouseScroll'];
var api = {
    getDelta: function (event, xaxis) {
        if (event.wheelDelta) {
            var delta = event.wheelDeltaY;
            if (xaxis) {
                delta = event.wheelDeltaX;
            }
            return delta;
        }
        else if (event.detail) {
            var oldFFWheelEvent = event;
            if (oldFFWheelEvent.axis && ((oldFFWheelEvent.axis === 1 && xaxis) || (oldFFWheelEvent.axis === 2 && !xaxis))) {
                return -1 * oldFFWheelEvent.detail * 12;
            }
        }
        else if (event.deltaX || event.deltaY) {
            if (xaxis) {
                return -1 * event.deltaX;
            }
            else {
                return -1 * event.deltaY;
            }
        }
        return 0;
    },
    bind: function (elem, listener) {
        var normalizedListener = function (e) {
            listener(normalizeWheelEvent(e));
        };
        EVENT_NAMES.forEach(function (name) {
            elem.addEventListener(name, normalizedListener);
        });
        return function () {
            EVENT_NAMES.forEach(function (name) {
                elem.removeEventListener(name, normalizedListener);
            });
        };
    },
    normalize: normalizeWheelEvent
};
function normalizeWheelEvent(e) {
    var deltaX = api.getDelta(e, true);
    var deltaY = api.getDelta(e);
    var newEvent = Object.create(e, {
        deltaY: {
            value: deltaY
        },
        deltaX: {
            value: deltaX
        },
        type: {
            value: 'mousewheel'
        },
        target: {
            value: e.target
        },
        currentTarget: {
            value: e.currentTarget
        },
        defaultPrevented: {
            value: false,
            writable: true
        }
    });
    newEvent.preventDefault = function () {
        newEvent.defaultPrevented = true;
        if (e && e.preventDefault) {
            e.preventDefault();
        }
    };
    return newEvent;
}
exports.default = api;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function default_1(d) {
    return d;
}
exports.default = default_1;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function add(grid, model) {
    if (model === void 0) { model = {}; }
    var api = Object.assign(model, { _decorators: {}, makeDecorator: model.makeDecorator || makeDecorator });
    function makeDecorator(col) {
        var decorator = grid.decorators.create(0, col, 1, 1, 'cell', 'real');
        decorator.getDecoratorLeft = function () {
            var firstRect = decorator.boundingBox &&
                decorator.boundingBox.getClientRects &&
                decorator.boundingBox.getClientRects()[0];
            return firstRect && grid.viewPort.toGridX(firstRect.left) || 0;
        };
        if (api.annotateDecorator) {
            api.annotateDecorator(decorator);
        }
        return decorator;
    }
    api.makeDecorator = api.makeDecorator || makeDecorator;
    function ensureDecoratorPerCol() {
        for (var c = 0; c < grid.viewPort.cols; c++) {
            if (!api._decorators[c]) {
                if (api.isNeeded && !api.isNeeded(c)) {
                    continue;
                }
                var decorator = api.makeDecorator(c);
                api._decorators[c] = decorator;
                grid.decorators.add(decorator);
            }
        }
    }
    grid.eventLoop.bind('grid-viewport-change', function () {
        ensureDecoratorPerCol();
    });
    ensureDecoratorPerCol();
    return api;
}
exports.add = add;
exports.default = add;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.stringify = function (data) {
    var stringResult = '';
    data.forEach(function (row, r) {
        row.forEach(function (value, c) {
            if (value.indexOf('\n') !== -1 || value.indexOf('\t') !== -1 || value.indexOf('"') !== -1) {
                value = '"' + value.replace(/"/g, '""') + '"';
            }
            stringResult += value;
            if (c !== row.length - 1) {
                stringResult += '\t';
            }
        });
        if (r !== data.length - 1) {
            stringResult += '\n';
        }
    });
    return stringResult;
};
function DSVToArray(strData, strDelimiter) {
    strDelimiter = (strDelimiter || ',');
    var objPattern = new RegExp(('(\\' + strDelimiter + '|\\r?\\n|\\r|^)' +
        '(?:"([^"]*(?:""[^"]*)*)"|' +
        '([^"\\' + strDelimiter + '\\r\\n]+))'), 'gi');
    var arrData = [
        []
    ];
    var arrMatches = null;
    while (arrMatches = objPattern.exec(strData)) {
        var strMatchedDelimiter = arrMatches[1];
        if (strMatchedDelimiter.length &&
            strMatchedDelimiter !== strDelimiter) {
            arrData.push([]);
        }
        var strMatchedValue = void 0;
        if (arrMatches[2]) {
            strMatchedValue = arrMatches[2].replace(new RegExp('""', 'g'), '"');
        }
        else {
            strMatchedValue = arrMatches[3];
        }
        arrData[arrData.length - 1].push(strMatchedValue);
    }
    return (arrData[0].length || !strData) && (arrData) || [
        [strData]
    ];
}
exports.parse = function (stringData) {
    return DSVToArray(stringData, '\t');
};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = function innerText(el) {
  if (el.innerText) return el.innerText;
  if (!window.getSelection) return 'ERROR: UUPS `window.getSelection` is not available.';

  var selection = window.getSelection();
  var ranges = [];
  var text;

  // Save existing selections.
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges[i] = selection.getRangeAt(i);
  }

  // Deselect everything.
  selection.removeAllRanges();

  // Select `el` and all child nodes.
  selection.selectAllChildren(el);

  // Get the string representation of the selected nodes.
  text = selection.toString();

  // Deselect everything. Again.
  selection.removeAllRanges();

  // Restore all formerly existing selections.
  for (var i = 0; i < ranges.length; i++) {
    selection.addRange(ranges[i]);
  }

  // Oh look, this is what we wanted.
  // String representation of the element, close to as rendered.
  return text;

};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var ref, special;

  ref = __webpack_require__(3).ref;

  special = {
    backspace: ref('Backspace', 8),
    tab: ref('Tab', 9),
    enter: ref('Enter', 13),
    shift: ref('Shift', 16),
    ctrl: ref('Ctrl', 17),
    alt: ref('Alt', 18),
    caps: ref('Caps Lock', 20),
    esc: ref('Escape', 27),
    space: ref('Space', 32),
    num: ref('Num Lock', 144)
  };

  module.exports = special;

}).call(this);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var arrow, ref;

  ref = __webpack_require__(3).ref;

  arrow = {
    left: ref('Left', 37),
    up: ref('Up', 38),
    right: ref('Right', 39),
    down: ref('Down', 40)
  };

  module.exports = arrow;

}).call(this);


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var punctuation, ref;

  ref = __webpack_require__(3).ref;

  punctuation = {
    colon: ref('Colon/Semicolon', [59, 186]),
    equal: ref('Equal/Plus', [61, 187]),
    comma: ref('Comma/Less Than', [44, 188]),
    hyphen: ref('Hyphen/Underscore', [45, 109, 189]),
    period: ref('Period/Greater Than', [46, 190]),
    tilde: ref('Tilde/Back Tick', [96, 192]),
    apostrophe: ref('Apostrophe/Quote', [39, 222]),
    slash: {
      forward: ref('Forward Slash/Question Mark', [47, 191]),
      backward: ref('Backward Slash/Pipe', 220)
    },
    brace: {
      square: {
        open: ref('Open Square/Curly Brace', 219),
        close: ref('Close Square/Curly Brace', 221)
      }
    }
  };

  punctuation.semicolon = punctuation.colon;

  punctuation.plus = punctuation.equal;

  punctuation.lessthan = punctuation.comma;

  punctuation.underscore = punctuation.hyphen;

  punctuation.greaterthan = punctuation.period;

  punctuation.question = punctuation.slash.forward;

  punctuation.backtick = punctuation.tilde;

  punctuation.pipe = punctuation.slash.backward;

  punctuation.quote = punctuation.apostrophe;

  punctuation.brace.curly = punctuation.brace.square;

  module.exports = punctuation;

}).call(this);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var alnum, ref;

  ref = __webpack_require__(3).ref;

  alnum = {
    '0': ref('0', 48),
    '1': ref('1', 49),
    '2': ref('2', 50),
    '3': ref('3', 51),
    '4': ref('4', 52),
    '5': ref('5', 53),
    '6': ref('6', 54),
    '7': ref('7', 55),
    '8': ref('8', 56),
    '9': ref('9', 57),
    a: ref('A', 65),
    b: ref('B', 66),
    c: ref('C', 67),
    d: ref('D', 68),
    e: ref('E', 69),
    f: ref('F', 70),
    g: ref('G', 71),
    h: ref('H', 72),
    i: ref('I', 73),
    j: ref('J', 74),
    k: ref('K', 75),
    l: ref('L', 76),
    m: ref('M', 77),
    n: ref('N', 78),
    o: ref('O', 79),
    p: ref('P', 80),
    q: ref('Q', 81),
    r: ref('R', 82),
    s: ref('S', 83),
    t: ref('T', 84),
    u: ref('U', 85),
    v: ref('V', 86),
    w: ref('W', 87),
    x: ref('X', 88),
    y: ref('Y', 89),
    z: ref('Z', 90)
  };

  module.exports = alnum;

}).call(this);


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var brand, ref;

  ref = __webpack_require__(3).ref;

  brand = {
    apple: ref('Apple &#8984;', 224),
    windows: {
      start: ref('Windows start', [91, 92]),
      menu: ref('Windows menu', 93)
    }
  };

  module.exports = brand;

}).call(this);


/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports.listen = function listenForClickOff(elem, onClickOff, opts) {
	var parsedOpts = opts || {}
		// we use mousedown to check the target because the click could cause the element to be removed and it'll look like it's not in us
	var lastMouseDownWasOutside = false;
	// check again after timeout
	var eventListenerElement = parsedOpts.eventListenerElement || document;
	var isInMe = parsedOpts.isInMe;

	function mousedownHandler(e) {
		if (typeof elem === 'function') {
			elem = elem();
		}
		lastMouseDownWasOutside = !elem || !(elem === e.target || elem.contains(e.target)) && !(isInMe && isInMe(e.target));
	}

	function mouseupHandler(e) {
		if (lastMouseDownWasOutside) {
			onClickOff(e);
		}
	}
	eventListenerElement.addEventListener('mousedown', mousedownHandler);
	eventListenerElement.addEventListener('mouseup', mouseupHandler);

	return function unbindClickOffListeners() {
		eventListenerElement.removeEventListener('mousedown', mousedownHandler);
		eventListenerElement.removeEventListener('mouseup', mouseupHandler);
	};
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (function() {
  var perf = window && window.performance;
  if (perf && perf.now) {
    return perf.now.bind(perf);
  } else {
    return function() {
      return new Date().getTime();
    };
  }
}());


/***/ }),
/* 53 */
/***/ (function(module, exports) {

var globalStack;

function makeStack() {
    var stack = [];

    // in order to capture escape event first
    document.body.addEventListener('keydown', function(e) {

        var key = e.keyCode ? e.keyCode : e.which;
        // yup i hard coded 27 sorry suckas
        if (key === 27) {
            while (!!stack.length && !(stack.pop())(e)) {}
        }
    }, true);

    function addEscapeHandler(handler) {
        stack.push(handler);
        return function() {
            removeEscapeHandler(handler);
        };
    }

    function removeEscapeHandler(handler) {
        var index = stack.indexOf(handler);
        if (index !== -1) {
            stack.splice(index, 1);
        }
    }
    return {
        add: addEscapeHandler
    };
}

module.exports = function(global) {
    if (!global) {
        return makeStack();
    }

    if (!globalStack) {
        globalStack = makeStack();
    }
    return globalStack;
};


/***/ })
/******/ ]);
});
//# sourceMappingURL=bundle.js.map